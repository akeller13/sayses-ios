// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: Mumble.proto
// Protobuf C++ Version: 6.33.4

#include "Mumble.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace MumbleProto {

inline constexpr VoiceTarget_Target::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        session_{},
        group_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        channel_id_{0u},
        links_{false},
        children_{false} {}

template <typename>
PROTOBUF_CONSTEXPR VoiceTarget_Target::VoiceTarget_Target(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(VoiceTarget_Target_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct VoiceTarget_TargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoiceTarget_TargetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoiceTarget_TargetDefaultTypeInternal() {}
  union {
    VoiceTarget_Target _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoiceTarget_TargetDefaultTypeInternal _VoiceTarget_Target_default_instance_;

inline constexpr Version::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        release_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        os_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        os_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        version_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Version::Version(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Version_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;

inline constexpr UserStats_Stats::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        good_{0u},
        late_{0u},
        lost_{0u},
        resync_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR UserStats_Stats::UserStats_Stats(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserStats_Stats_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserStats_StatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStats_StatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStats_StatsDefaultTypeInternal() {}
  union {
    UserStats_Stats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStats_StatsDefaultTypeInternal _UserStats_Stats_default_instance_;

inline constexpr UserState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        texture_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        plugin_context_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        plugin_identity_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        comment_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        comment_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        texture_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        session_{0u},
        actor_{0u},
        user_id_{0u},
        channel_id_{0u},
        mute_{false},
        deaf_{false},
        suppress_{false},
        self_mute_{false},
        self_deaf_{false},
        priority_speaker_{false},
        recording_{false} {}

template <typename>
PROTOBUF_CONSTEXPR UserState::UserState(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserState_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStateDefaultTypeInternal() {}
  union {
    UserState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStateDefaultTypeInternal _UserState_default_instance_;

inline constexpr UserRemove::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        session_{0u},
        actor_{0u},
        ban_{false} {}

template <typename>
PROTOBUF_CONSTEXPR UserRemove::UserRemove(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserRemove_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserRemoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserRemoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserRemoveDefaultTypeInternal() {}
  union {
    UserRemove _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserRemoveDefaultTypeInternal _UserRemove_default_instance_;

inline constexpr UserList_User::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        last_seen_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        user_id_{0u},
        last_channel_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR UserList_User::UserList_User(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserList_User_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserList_UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserList_UserDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserList_UserDefaultTypeInternal() {}
  union {
    UserList_User _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserList_UserDefaultTypeInternal _UserList_User_default_instance_;

inline constexpr UDPTunnel::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        packet_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR UDPTunnel::UDPTunnel(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UDPTunnel_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UDPTunnelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UDPTunnelDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UDPTunnelDefaultTypeInternal() {}
  union {
    UDPTunnel _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UDPTunnelDefaultTypeInternal _UDPTunnel_default_instance_;

inline constexpr TextMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        session_{},
        channel_id_{},
        tree_id_{},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        actor_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR TextMessage::TextMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(TextMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct TextMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextMessageDefaultTypeInternal() {}
  union {
    TextMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextMessageDefaultTypeInternal _TextMessage_default_instance_;

inline constexpr SuggestConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        version_{0u},
        positional_{false},
        push_to_talk_{false} {}

template <typename>
PROTOBUF_CONSTEXPR SuggestConfig::SuggestConfig(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SuggestConfig_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SuggestConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SuggestConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SuggestConfigDefaultTypeInternal() {}
  union {
    SuggestConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SuggestConfigDefaultTypeInternal _SuggestConfig_default_instance_;

inline constexpr ServerSync::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        welcome_text_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        session_{0u},
        max_bandwidth_{0u},
        permissions_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR ServerSync::ServerSync(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ServerSync_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ServerSyncDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerSyncDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerSyncDefaultTypeInternal() {}
  union {
    ServerSync _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerSyncDefaultTypeInternal _ServerSync_default_instance_;

inline constexpr ServerConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        welcome_text_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        max_bandwidth_{0u},
        allow_html_{false},
        message_length_{0u},
        image_message_length_{0u},
        max_users_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR ServerConfig::ServerConfig(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ServerConfig_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ServerConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ServerConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ServerConfigDefaultTypeInternal() {}
  union {
    ServerConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerConfigDefaultTypeInternal _ServerConfig_default_instance_;

inline constexpr RequestBlob::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        session_texture_{},
        session_comment_{},
        channel_description_{} {}

template <typename>
PROTOBUF_CONSTEXPR RequestBlob::RequestBlob(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RequestBlob_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RequestBlobDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestBlobDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestBlobDefaultTypeInternal() {}
  union {
    RequestBlob _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestBlobDefaultTypeInternal _RequestBlob_default_instance_;

inline constexpr Reject::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_{static_cast< ::MumbleProto::Reject_RejectType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR Reject::Reject(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Reject_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RejectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RejectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RejectDefaultTypeInternal() {}
  union {
    Reject _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RejectDefaultTypeInternal _Reject_default_instance_;

inline constexpr QueryUsers::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        ids_{},
        names_{} {}

template <typename>
PROTOBUF_CONSTEXPR QueryUsers::QueryUsers(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(QueryUsers_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct QueryUsersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryUsersDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryUsersDefaultTypeInternal() {}
  union {
    QueryUsers _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryUsersDefaultTypeInternal _QueryUsers_default_instance_;

inline constexpr Ping::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_{::uint64_t{0u}},
        good_{0u},
        late_{0u},
        lost_{0u},
        resync_{0u},
        udp_packets_{0u},
        tcp_packets_{0u},
        udp_ping_avg_{0},
        udp_ping_var_{0},
        tcp_ping_avg_{0},
        tcp_ping_var_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Ping::Ping(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Ping_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PingDefaultTypeInternal() {}
  union {
    Ping _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PingDefaultTypeInternal _Ping_default_instance_;

inline constexpr PermissionQuery::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channel_id_{0u},
        permissions_{0u},
        flush_{false} {}

template <typename>
PROTOBUF_CONSTEXPR PermissionQuery::PermissionQuery(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PermissionQuery_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PermissionQueryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionQueryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionQueryDefaultTypeInternal() {}
  union {
    PermissionQuery _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionQueryDefaultTypeInternal _PermissionQuery_default_instance_;

inline constexpr PermissionDenied::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        permission_{0u},
        channel_id_{0u},
        session_{0u},
        type_{static_cast< ::MumbleProto::PermissionDenied_DenyType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR PermissionDenied::PermissionDenied(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(PermissionDenied_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PermissionDeniedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PermissionDeniedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PermissionDeniedDefaultTypeInternal() {}
  union {
    PermissionDenied _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionDeniedDefaultTypeInternal _PermissionDenied_default_instance_;

inline constexpr CryptSetup::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        client_nonce_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        server_nonce_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR CryptSetup::CryptSetup(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CryptSetup_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CryptSetupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CryptSetupDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CryptSetupDefaultTypeInternal() {}
  union {
    CryptSetup _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CryptSetupDefaultTypeInternal _CryptSetup_default_instance_;

inline constexpr ContextActionModify::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        action_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        text_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        context_{0u},
        operation_{static_cast< ::MumbleProto::ContextActionModify_Operation >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR ContextActionModify::ContextActionModify(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ContextActionModify_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ContextActionModifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContextActionModifyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContextActionModifyDefaultTypeInternal() {}
  union {
    ContextActionModify _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContextActionModifyDefaultTypeInternal _ContextActionModify_default_instance_;

inline constexpr ContextAction::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        action_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        session_{0u},
        channel_id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR ContextAction::ContextAction(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ContextAction_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ContextActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContextActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContextActionDefaultTypeInternal() {}
  union {
    ContextAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContextActionDefaultTypeInternal _ContextAction_default_instance_;

inline constexpr CodecVersion::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        alpha_{0},
        beta_{0},
        opus_{false},
        prefer_alpha_{true} {}

template <typename>
PROTOBUF_CONSTEXPR CodecVersion::CodecVersion(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(CodecVersion_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CodecVersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CodecVersionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CodecVersionDefaultTypeInternal() {}
  union {
    CodecVersion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CodecVersionDefaultTypeInternal _CodecVersion_default_instance_;

inline constexpr ChannelState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        links_{},
        links_add_{},
        links_remove_{},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        channel_id_{0u},
        parent_{0u},
        temporary_{false},
        position_{0},
        max_users_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR ChannelState::ChannelState(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ChannelState_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChannelStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChannelStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChannelStateDefaultTypeInternal() {}
  union {
    ChannelState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChannelStateDefaultTypeInternal _ChannelState_default_instance_;

inline constexpr ChannelRemove::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        channel_id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR ChannelRemove::ChannelRemove(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ChannelRemove_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChannelRemoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChannelRemoveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChannelRemoveDefaultTypeInternal() {}
  union {
    ChannelRemove _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChannelRemoveDefaultTypeInternal _ChannelRemove_default_instance_;

inline constexpr BanList_BanEntry::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        start_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        mask_{0u},
        duration_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR BanList_BanEntry::BanList_BanEntry(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(BanList_BanEntry_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BanList_BanEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BanList_BanEntryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BanList_BanEntryDefaultTypeInternal() {}
  union {
    BanList_BanEntry _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BanList_BanEntryDefaultTypeInternal _BanList_BanEntry_default_instance_;

inline constexpr Authenticate::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        tokens_{},
        celt_versions_{},
        username_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        password_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        opus_{false} {}

template <typename>
PROTOBUF_CONSTEXPR Authenticate::Authenticate(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Authenticate_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AuthenticateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticateDefaultTypeInternal() {}
  union {
    Authenticate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticateDefaultTypeInternal _Authenticate_default_instance_;

inline constexpr ACL_ChanGroup::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        add_{},
        remove_{},
        inherited_members_{},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        inherited_{true},
        inherit_{true},
        inheritable_{true} {}

template <typename>
PROTOBUF_CONSTEXPR ACL_ChanGroup::ACL_ChanGroup(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ACL_ChanGroup_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ACL_ChanGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACL_ChanGroupDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACL_ChanGroupDefaultTypeInternal() {}
  union {
    ACL_ChanGroup _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACL_ChanGroupDefaultTypeInternal _ACL_ChanGroup_default_instance_;

inline constexpr ACL_ChanACL::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        group_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        user_id_{0u},
        grant_{0u},
        deny_{0u},
        apply_here_{true},
        apply_subs_{true},
        inherited_{true} {}

template <typename>
PROTOBUF_CONSTEXPR ACL_ChanACL::ACL_ChanACL(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ACL_ChanACL_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ACL_ChanACLDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACL_ChanACLDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACL_ChanACLDefaultTypeInternal() {}
  union {
    ACL_ChanACL _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACL_ChanACLDefaultTypeInternal _ACL_ChanACL_default_instance_;

inline constexpr VoiceTarget::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        targets_{},
        id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR VoiceTarget::VoiceTarget(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(VoiceTarget_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct VoiceTargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoiceTargetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoiceTargetDefaultTypeInternal() {}
  union {
    VoiceTarget _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoiceTargetDefaultTypeInternal _VoiceTarget_default_instance_;

inline constexpr UserStats::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        certificates_{},
        celt_versions_{},
        address_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        from_client_{nullptr},
        from_server_{nullptr},
        version_{nullptr},
        session_{0u},
        udp_packets_{0u},
        tcp_packets_{0u},
        udp_ping_avg_{0},
        udp_ping_var_{0},
        tcp_ping_avg_{0},
        tcp_ping_var_{0},
        stats_only_{false},
        strong_certificate_{false},
        opus_{false},
        bandwidth_{0u},
        onlinesecs_{0u},
        idlesecs_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR UserStats::UserStats(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserStats_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStatsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStatsDefaultTypeInternal() {}
  union {
    UserStats _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStatsDefaultTypeInternal _UserStats_default_instance_;

inline constexpr UserList::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        users_{} {}

template <typename>
PROTOBUF_CONSTEXPR UserList::UserList(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(UserList_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserListDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserListDefaultTypeInternal() {}
  union {
    UserList _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserListDefaultTypeInternal _UserList_default_instance_;

inline constexpr BanList::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        bans_{},
        query_{false} {}

template <typename>
PROTOBUF_CONSTEXPR BanList::BanList(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(BanList_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct BanListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BanListDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BanListDefaultTypeInternal() {}
  union {
    BanList _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BanListDefaultTypeInternal _BanList_default_instance_;

inline constexpr ACL::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        groups_{},
        acls_{},
        channel_id_{0u},
        query_{false},
        inherit_acls_{true} {}

template <typename>
PROTOBUF_CONSTEXPR ACL::ACL(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ACL_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ACLDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACLDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACLDefaultTypeInternal() {}
  union {
    ACL _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACLDefaultTypeInternal _ACL_default_instance_;
}  // namespace MumbleProto
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_Mumble_2eproto[4];
static constexpr const ::_pb::ServiceDescriptor* PROTOBUF_NONNULL* PROTOBUF_NULLABLE
    file_level_service_descriptors_Mumble_2eproto = nullptr;
const ::uint32_t
    TableStruct_Mumble_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Version, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Version, _impl_.version_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Version, _impl_.release_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Version, _impl_.os_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Version, _impl_.os_version_),
        3,
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UDPTunnel, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UDPTunnel, _impl_.packet_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Authenticate, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Authenticate, _impl_.username_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Authenticate, _impl_.password_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Authenticate, _impl_.tokens_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Authenticate, _impl_.celt_versions_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Authenticate, _impl_.opus_),
        2,
        3,
        0,
        1,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_._has_bits_),
        14, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.timestamp_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.good_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.late_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.lost_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.resync_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.udp_packets_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.tcp_packets_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.udp_ping_avg_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.udp_ping_var_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.tcp_ping_avg_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Ping, _impl_.tcp_ping_var_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Reject, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Reject, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::Reject, _impl_.reason_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerSync, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerSync, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerSync, _impl_.max_bandwidth_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerSync, _impl_.welcome_text_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerSync, _impl_.permissions_),
        1,
        2,
        0,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelRemove, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelRemove, _impl_.channel_id_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_._has_bits_),
        14, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.parent_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.links_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.description_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.links_add_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.links_remove_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.temporary_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.description_hash_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ChannelState, _impl_.max_users_),
        6,
        7,
        3,
        0,
        4,
        1,
        2,
        8,
        9,
        5,
        10,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserRemove, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserRemove, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserRemove, _impl_.actor_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserRemove, _impl_.reason_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserRemove, _impl_.ban_),
        1,
        2,
        0,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_._has_bits_),
        22, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.actor_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.user_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.mute_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.deaf_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.suppress_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.self_mute_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.self_deaf_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.texture_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.plugin_context_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.plugin_identity_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.comment_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.hash_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.comment_hash_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.texture_hash_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.priority_speaker_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserState, _impl_.recording_),
        8,
        9,
        0,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        17,
        18,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList_BanEntry, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList_BanEntry, _impl_.address_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList_BanEntry, _impl_.mask_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList_BanEntry, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList_BanEntry, _impl_.hash_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList_BanEntry, _impl_.reason_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList_BanEntry, _impl_.start_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList_BanEntry, _impl_.duration_),
        0,
        5,
        1,
        2,
        3,
        4,
        6,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList, _impl_.bans_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::BanList, _impl_.query_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::TextMessage, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::TextMessage, _impl_.actor_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::TextMessage, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::TextMessage, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::TextMessage, _impl_.tree_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::TextMessage, _impl_.message_),
        4,
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionDenied, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionDenied, _impl_.permission_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionDenied, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionDenied, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionDenied, _impl_.reason_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionDenied, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionDenied, _impl_.name_),
        2,
        3,
        4,
        0,
        5,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanGroup, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanGroup, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanGroup, _impl_.inherited_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanGroup, _impl_.inherit_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanGroup, _impl_.inheritable_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanGroup, _impl_.add_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanGroup, _impl_.remove_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanGroup, _impl_.inherited_members_),
        3,
        4,
        5,
        6,
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanACL, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanACL, _impl_.apply_here_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanACL, _impl_.apply_subs_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanACL, _impl_.inherited_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanACL, _impl_.user_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanACL, _impl_.group_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanACL, _impl_.grant_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL_ChanACL, _impl_.deny_),
        4,
        5,
        6,
        1,
        0,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL, _impl_.inherit_acls_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL, _impl_.groups_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL, _impl_.acls_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ACL, _impl_.query_),
        2,
        4,
        0,
        1,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::QueryUsers, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::QueryUsers, _impl_.ids_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::QueryUsers, _impl_.names_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CryptSetup, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CryptSetup, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CryptSetup, _impl_.client_nonce_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CryptSetup, _impl_.server_nonce_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextActionModify, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextActionModify, _impl_.action_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextActionModify, _impl_.text_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextActionModify, _impl_.context_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextActionModify, _impl_.operation_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextAction, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextAction, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextAction, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ContextAction, _impl_.action_),
        1,
        2,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserList_User, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserList_User, _impl_.user_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserList_User, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserList_User, _impl_.last_seen_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserList_User, _impl_.last_channel_),
        2,
        0,
        1,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserList, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserList, _impl_.users_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget_Target, _impl_._has_bits_),
        8, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget_Target, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget_Target, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget_Target, _impl_.group_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget_Target, _impl_.links_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget_Target, _impl_.children_),
        0,
        2,
        1,
        3,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::VoiceTarget, _impl_.targets_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionQuery, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionQuery, _impl_.channel_id_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionQuery, _impl_.permissions_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::PermissionQuery, _impl_.flush_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CodecVersion, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CodecVersion, _impl_.alpha_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CodecVersion, _impl_.beta_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CodecVersion, _impl_.prefer_alpha_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::CodecVersion, _impl_.opus_),
        0,
        1,
        3,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats_Stats, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats_Stats, _impl_.good_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats_Stats, _impl_.late_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats_Stats, _impl_.lost_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats_Stats, _impl_.resync_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_._has_bits_),
        22, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.session_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.stats_only_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.certificates_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.from_client_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.from_server_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.udp_packets_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.tcp_packets_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.udp_ping_avg_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.udp_ping_var_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.tcp_ping_avg_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.tcp_ping_var_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.version_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.celt_versions_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.address_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.bandwidth_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.onlinesecs_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.idlesecs_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.strong_certificate_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::UserStats, _impl_.opus_),
        6,
        13,
        0,
        3,
        4,
        7,
        8,
        9,
        10,
        11,
        12,
        5,
        1,
        2,
        16,
        17,
        18,
        14,
        15,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::RequestBlob, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::RequestBlob, _impl_.session_texture_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::RequestBlob, _impl_.session_comment_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::RequestBlob, _impl_.channel_description_),
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerConfig, _impl_._has_bits_),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerConfig, _impl_.max_bandwidth_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerConfig, _impl_.welcome_text_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerConfig, _impl_.allow_html_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerConfig, _impl_.message_length_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerConfig, _impl_.image_message_length_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::ServerConfig, _impl_.max_users_),
        1,
        0,
        2,
        3,
        4,
        5,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::MumbleProto::SuggestConfig, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::MumbleProto::SuggestConfig, _impl_.version_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::SuggestConfig, _impl_.positional_),
        PROTOBUF_FIELD_OFFSET(::MumbleProto::SuggestConfig, _impl_.push_to_talk_),
        0,
        1,
        2,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::MumbleProto::Version)},
        {11, sizeof(::MumbleProto::UDPTunnel)},
        {16, sizeof(::MumbleProto::Authenticate)},
        {29, sizeof(::MumbleProto::Ping)},
        {54, sizeof(::MumbleProto::Reject)},
        {61, sizeof(::MumbleProto::ServerSync)},
        {72, sizeof(::MumbleProto::ChannelRemove)},
        {77, sizeof(::MumbleProto::ChannelState)},
        {102, sizeof(::MumbleProto::UserRemove)},
        {113, sizeof(::MumbleProto::UserState)},
        {154, sizeof(::MumbleProto::BanList_BanEntry)},
        {171, sizeof(::MumbleProto::BanList)},
        {178, sizeof(::MumbleProto::TextMessage)},
        {191, sizeof(::MumbleProto::PermissionDenied)},
        {206, sizeof(::MumbleProto::ACL_ChanGroup)},
        {223, sizeof(::MumbleProto::ACL_ChanACL)},
        {240, sizeof(::MumbleProto::ACL)},
        {253, sizeof(::MumbleProto::QueryUsers)},
        {260, sizeof(::MumbleProto::CryptSetup)},
        {269, sizeof(::MumbleProto::ContextActionModify)},
        {280, sizeof(::MumbleProto::ContextAction)},
        {289, sizeof(::MumbleProto::UserList_User)},
        {300, sizeof(::MumbleProto::UserList)},
        {305, sizeof(::MumbleProto::VoiceTarget_Target)},
        {318, sizeof(::MumbleProto::VoiceTarget)},
        {325, sizeof(::MumbleProto::PermissionQuery)},
        {334, sizeof(::MumbleProto::CodecVersion)},
        {345, sizeof(::MumbleProto::UserStats_Stats)},
        {356, sizeof(::MumbleProto::UserStats)},
        {397, sizeof(::MumbleProto::RequestBlob)},
        {406, sizeof(::MumbleProto::ServerConfig)},
        {421, sizeof(::MumbleProto::SuggestConfig)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::MumbleProto::_Version_default_instance_._instance,
    &::MumbleProto::_UDPTunnel_default_instance_._instance,
    &::MumbleProto::_Authenticate_default_instance_._instance,
    &::MumbleProto::_Ping_default_instance_._instance,
    &::MumbleProto::_Reject_default_instance_._instance,
    &::MumbleProto::_ServerSync_default_instance_._instance,
    &::MumbleProto::_ChannelRemove_default_instance_._instance,
    &::MumbleProto::_ChannelState_default_instance_._instance,
    &::MumbleProto::_UserRemove_default_instance_._instance,
    &::MumbleProto::_UserState_default_instance_._instance,
    &::MumbleProto::_BanList_BanEntry_default_instance_._instance,
    &::MumbleProto::_BanList_default_instance_._instance,
    &::MumbleProto::_TextMessage_default_instance_._instance,
    &::MumbleProto::_PermissionDenied_default_instance_._instance,
    &::MumbleProto::_ACL_ChanGroup_default_instance_._instance,
    &::MumbleProto::_ACL_ChanACL_default_instance_._instance,
    &::MumbleProto::_ACL_default_instance_._instance,
    &::MumbleProto::_QueryUsers_default_instance_._instance,
    &::MumbleProto::_CryptSetup_default_instance_._instance,
    &::MumbleProto::_ContextActionModify_default_instance_._instance,
    &::MumbleProto::_ContextAction_default_instance_._instance,
    &::MumbleProto::_UserList_User_default_instance_._instance,
    &::MumbleProto::_UserList_default_instance_._instance,
    &::MumbleProto::_VoiceTarget_Target_default_instance_._instance,
    &::MumbleProto::_VoiceTarget_default_instance_._instance,
    &::MumbleProto::_PermissionQuery_default_instance_._instance,
    &::MumbleProto::_CodecVersion_default_instance_._instance,
    &::MumbleProto::_UserStats_Stats_default_instance_._instance,
    &::MumbleProto::_UserStats_default_instance_._instance,
    &::MumbleProto::_RequestBlob_default_instance_._instance,
    &::MumbleProto::_ServerConfig_default_instance_._instance,
    &::MumbleProto::_SuggestConfig_default_instance_._instance,
};
const char descriptor_table_protodef_Mumble_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\014Mumble.proto\022\013MumbleProto\"K\n\007Version\022\017"
    "\n\007version\030\001 \001(\r\022\017\n\007release\030\002 \001(\t\022\n\n\002os\030\003"
    " \001(\t\022\022\n\nos_version\030\004 \001(\t\"\033\n\tUDPTunnel\022\016\n"
    "\006packet\030\001 \002(\014\"n\n\014Authenticate\022\020\n\010usernam"
    "e\030\001 \001(\t\022\020\n\010password\030\002 \001(\t\022\016\n\006tokens\030\003 \003("
    "\t\022\025\n\rcelt_versions\030\004 \003(\005\022\023\n\004opus\030\005 \001(\010:\005"
    "false\"\325\001\n\004Ping\022\021\n\ttimestamp\030\001 \001(\004\022\014\n\004goo"
    "d\030\002 \001(\r\022\014\n\004late\030\003 \001(\r\022\014\n\004lost\030\004 \001(\r\022\016\n\006r"
    "esync\030\005 \001(\r\022\023\n\013udp_packets\030\006 \001(\r\022\023\n\013tcp_"
    "packets\030\007 \001(\r\022\024\n\014udp_ping_avg\030\010 \001(\002\022\024\n\014u"
    "dp_ping_var\030\t \001(\002\022\024\n\014tcp_ping_avg\030\n \001(\002\022"
    "\024\n\014tcp_ping_var\030\013 \001(\002\"\367\001\n\006Reject\022,\n\004type"
    "\030\001 \001(\0162\036.MumbleProto.Reject.RejectType\022\016"
    "\n\006reason\030\002 \001(\t\"\256\001\n\nRejectType\022\010\n\004None\020\000\022"
    "\020\n\014WrongVersion\020\001\022\023\n\017InvalidUsername\020\002\022\017"
    "\n\013WrongUserPW\020\003\022\021\n\rWrongServerPW\020\004\022\021\n\rUs"
    "ernameInUse\020\005\022\016\n\nServerFull\020\006\022\021\n\rNoCerti"
    "ficate\020\007\022\025\n\021AuthenticatorFail\020\010\"_\n\nServe"
    "rSync\022\017\n\007session\030\001 \001(\r\022\025\n\rmax_bandwidth\030"
    "\002 \001(\r\022\024\n\014welcome_text\030\003 \001(\t\022\023\n\013permissio"
    "ns\030\004 \001(\004\"#\n\rChannelRemove\022\022\n\nchannel_id\030"
    "\001 \002(\r\"\351\001\n\014ChannelState\022\022\n\nchannel_id\030\001 \001"
    "(\r\022\016\n\006parent\030\002 \001(\r\022\014\n\004name\030\003 \001(\t\022\r\n\005link"
    "s\030\004 \003(\r\022\023\n\013description\030\005 \001(\t\022\021\n\tlinks_ad"
    "d\030\006 \003(\r\022\024\n\014links_remove\030\007 \003(\r\022\030\n\ttempora"
    "ry\030\010 \001(\010:\005false\022\023\n\010position\030\t \001(\005:\0010\022\030\n\020"
    "description_hash\030\n \001(\014\022\021\n\tmax_users\030\013 \001("
    "\r\"I\n\nUserRemove\022\017\n\007session\030\001 \002(\r\022\r\n\005acto"
    "r\030\002 \001(\r\022\016\n\006reason\030\003 \001(\t\022\013\n\003ban\030\004 \001(\010\"\354\002\n"
    "\tUserState\022\017\n\007session\030\001 \001(\r\022\r\n\005actor\030\002 \001"
    "(\r\022\014\n\004name\030\003 \001(\t\022\017\n\007user_id\030\004 \001(\r\022\022\n\ncha"
    "nnel_id\030\005 \001(\r\022\014\n\004mute\030\006 \001(\010\022\014\n\004deaf\030\007 \001("
    "\010\022\020\n\010suppress\030\010 \001(\010\022\021\n\tself_mute\030\t \001(\010\022\021"
    "\n\tself_deaf\030\n \001(\010\022\017\n\007texture\030\013 \001(\014\022\026\n\016pl"
    "ugin_context\030\014 \001(\014\022\027\n\017plugin_identity\030\r "
    "\001(\t\022\017\n\007comment\030\016 \001(\t\022\014\n\004hash\030\017 \001(\t\022\024\n\014co"
    "mment_hash\030\020 \001(\014\022\024\n\014texture_hash\030\021 \001(\014\022\030"
    "\n\020priority_speaker\030\022 \001(\010\022\021\n\trecording\030\023 "
    "\001(\010\"\304\001\n\007BanList\022+\n\004bans\030\001 \003(\0132\035.MumblePr"
    "oto.BanList.BanEntry\022\024\n\005query\030\002 \001(\010:\005fal"
    "se\032v\n\010BanEntry\022\017\n\007address\030\001 \002(\014\022\014\n\004mask\030"
    "\002 \002(\r\022\014\n\004name\030\003 \001(\t\022\014\n\004hash\030\004 \001(\t\022\016\n\006rea"
    "son\030\005 \001(\t\022\r\n\005start\030\006 \001(\t\022\020\n\010duration\030\007 \001"
    "(\r\"c\n\013TextMessage\022\r\n\005actor\030\001 \001(\r\022\017\n\007sess"
    "ion\030\002 \003(\r\022\022\n\nchannel_id\030\003 \003(\r\022\017\n\007tree_id"
    "\030\004 \003(\r\022\017\n\007message\030\005 \002(\t\"\366\002\n\020PermissionDe"
    "nied\022\022\n\npermission\030\001 \001(\r\022\022\n\nchannel_id\030\002"
    " \001(\r\022\017\n\007session\030\003 \001(\r\022\016\n\006reason\030\004 \001(\t\0224\n"
    "\004type\030\005 \001(\0162&.MumbleProto.PermissionDeni"
    "ed.DenyType\022\014\n\004name\030\006 \001(\t\"\324\001\n\010DenyType\022\010"
    "\n\004Text\020\000\022\016\n\nPermission\020\001\022\r\n\tSuperUser\020\002\022"
    "\017\n\013ChannelName\020\003\022\017\n\013TextTooLong\020\004\022\007\n\003H9K"
    "\020\005\022\024\n\020TemporaryChannel\020\006\022\026\n\022MissingCerti"
    "ficate\020\007\022\014\n\010UserName\020\010\022\017\n\013ChannelFull\020\t\022"
    "\020\n\014NestingLimit\020\n\022\025\n\021ChannelCountLimit\020\013"
    "\"\324\003\n\003ACL\022\022\n\nchannel_id\030\001 \002(\r\022\032\n\014inherit_"
    "acls\030\002 \001(\010:\004true\022*\n\006groups\030\003 \003(\0132\032.Mumbl"
    "eProto.ACL.ChanGroup\022&\n\004acls\030\004 \003(\0132\030.Mum"
    "bleProto.ACL.ChanACL\022\024\n\005query\030\005 \001(\010:\005fal"
    "se\032\234\001\n\tChanGroup\022\014\n\004name\030\001 \002(\t\022\027\n\tinheri"
    "ted\030\002 \001(\010:\004true\022\025\n\007inherit\030\003 \001(\010:\004true\022\031"
    "\n\013inheritable\030\004 \001(\010:\004true\022\013\n\003add\030\005 \003(\r\022\016"
    "\n\006remove\030\006 \003(\r\022\031\n\021inherited_members\030\007 \003("
    "\r\032\223\001\n\007ChanACL\022\030\n\napply_here\030\001 \001(\010:\004true\022"
    "\030\n\napply_subs\030\002 \001(\010:\004true\022\027\n\tinherited\030\003"
    " \001(\010:\004true\022\017\n\007user_id\030\004 \001(\r\022\r\n\005group\030\005 \001"
    "(\t\022\r\n\005grant\030\006 \001(\r\022\014\n\004deny\030\007 \001(\r\"(\n\nQuery"
    "Users\022\013\n\003ids\030\001 \003(\r\022\r\n\005names\030\002 \003(\t\"E\n\nCry"
    "ptSetup\022\013\n\003key\030\001 \001(\014\022\024\n\014client_nonce\030\002 \001"
    "(\014\022\024\n\014server_nonce\030\003 \001(\014\"\323\001\n\023ContextActi"
    "onModify\022\016\n\006action\030\001 \002(\t\022\014\n\004text\030\002 \001(\t\022\017"
    "\n\007context\030\003 \001(\r\022=\n\toperation\030\004 \001(\0162*.Mum"
    "bleProto.ContextActionModify.Operation\","
    "\n\007Context\022\n\n\006Server\020\001\022\013\n\007Channel\020\002\022\010\n\004Us"
    "er\020\004\" \n\tOperation\022\007\n\003Add\020\000\022\n\n\006Remove\020\001\"D"
    "\n\rContextAction\022\017\n\007session\030\001 \001(\r\022\022\n\nchan"
    "nel_id\030\002 \001(\r\022\016\n\006action\030\003 \002(\t\"\205\001\n\010UserLis"
    "t\022)\n\005users\030\001 \003(\0132\032.MumbleProto.UserList."
    "User\032N\n\004User\022\017\n\007user_id\030\001 \002(\r\022\014\n\004name\030\002 "
    "\001(\t\022\021\n\tlast_seen\030\003 \001(\t\022\024\n\014last_channel\030\004"
    " \001(\r\"\270\001\n\013VoiceTarget\022\n\n\002id\030\001 \001(\r\0220\n\007targ"
    "ets\030\002 \003(\0132\037.MumbleProto.VoiceTarget.Targ"
    "et\032k\n\006Target\022\017\n\007session\030\001 \003(\r\022\022\n\nchannel"
    "_id\030\002 \001(\r\022\r\n\005group\030\003 \001(\t\022\024\n\005links\030\004 \001(\010:"
    "\005false\022\027\n\010children\030\005 \001(\010:\005false\"P\n\017Permi"
    "ssionQuery\022\022\n\nchannel_id\030\001 \001(\r\022\023\n\013permis"
    "sions\030\002 \001(\r\022\024\n\005flush\030\003 \001(\010:\005false\"\\\n\014Cod"
    "ecVersion\022\r\n\005alpha\030\001 \002(\005\022\014\n\004beta\030\002 \002(\005\022\032"
    "\n\014prefer_alpha\030\003 \002(\010:\004true\022\023\n\004opus\030\004 \001(\010"
    ":\005false\"\270\004\n\tUserStats\022\017\n\007session\030\001 \001(\r\022\031"
    "\n\nstats_only\030\002 \001(\010:\005false\022\024\n\014certificate"
    "s\030\003 \003(\014\0221\n\013from_client\030\004 \001(\0132\034.MumblePro"
    "to.UserStats.Stats\0221\n\013from_server\030\005 \001(\0132"
    "\034.MumbleProto.UserStats.Stats\022\023\n\013udp_pac"
    "kets\030\006 \001(\r\022\023\n\013tcp_packets\030\007 \001(\r\022\024\n\014udp_p"
    "ing_avg\030\010 \001(\002\022\024\n\014udp_ping_var\030\t \001(\002\022\024\n\014t"
    "cp_ping_avg\030\n \001(\002\022\024\n\014tcp_ping_var\030\013 \001(\002\022"
    "%\n\007version\030\014 \001(\0132\024.MumbleProto.Version\022\025"
    "\n\rcelt_versions\030\r \003(\005\022\017\n\007address\030\016 \001(\014\022\021"
    "\n\tbandwidth\030\017 \001(\r\022\022\n\nonlinesecs\030\020 \001(\r\022\020\n"
    "\010idlesecs\030\021 \001(\r\022!\n\022strong_certificate\030\022 "
    "\001(\010:\005false\022\023\n\004opus\030\023 \001(\010:\005false\032A\n\005Stats"
    "\022\014\n\004good\030\001 \001(\r\022\014\n\004late\030\002 \001(\r\022\014\n\004lost\030\003 \001"
    "(\r\022\016\n\006resync\030\004 \001(\r\"\\\n\013RequestBlob\022\027\n\017ses"
    "sion_texture\030\001 \003(\r\022\027\n\017session_comment\030\002 "
    "\003(\r\022\033\n\023channel_description\030\003 \003(\r\"\230\001\n\014Ser"
    "verConfig\022\025\n\rmax_bandwidth\030\001 \001(\r\022\024\n\014welc"
    "ome_text\030\002 \001(\t\022\022\n\nallow_html\030\003 \001(\010\022\026\n\016me"
    "ssage_length\030\004 \001(\r\022\034\n\024image_message_leng"
    "th\030\005 \001(\r\022\021\n\tmax_users\030\006 \001(\r\"J\n\rSuggestCo"
    "nfig\022\017\n\007version\030\001 \001(\r\022\022\n\npositional\030\002 \001("
    "\010\022\024\n\014push_to_talk\030\003 \001(\010B\002H\001"
};
static ::absl::once_flag descriptor_table_Mumble_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_Mumble_2eproto = {
    false,
    false,
    4467,
    descriptor_table_protodef_Mumble_2eproto,
    "Mumble.proto",
    &descriptor_table_Mumble_2eproto_once,
    nullptr,
    0,
    32,
    schemas,
    file_default_instances,
    TableStruct_Mumble_2eproto::offsets,
    file_level_enum_descriptors_Mumble_2eproto,
    file_level_service_descriptors_Mumble_2eproto,
};
namespace MumbleProto {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Reject_RejectType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Mumble_2eproto);
  return file_level_enum_descriptors_Mumble_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t Reject_RejectType_internal_data_[] = {
    589824u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PermissionDenied_DenyType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Mumble_2eproto);
  return file_level_enum_descriptors_Mumble_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t PermissionDenied_DenyType_internal_data_[] = {
    786432u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ContextActionModify_Context_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Mumble_2eproto);
  return file_level_enum_descriptors_Mumble_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t ContextActionModify_Context_internal_data_[] = {
    131073u, 32u, 2u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ContextActionModify_Operation_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Mumble_2eproto);
  return file_level_enum_descriptors_Mumble_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t ContextActionModify_Operation_internal_data_[] = {
    131072u, 0u, };
// ===================================================================

class Version::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Version>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Version, _impl_._has_bits_);
};

Version::Version(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Version_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.Version)
}
PROTOBUF_NDEBUG_INLINE Version::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::Version& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        release_(arena, from.release_),
        os_(arena, from.os_),
        os_version_(arena, from.os_version_) {}

Version::Version(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Version& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Version_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Version* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.version_ = from._impl_.version_;

  // @@protoc_insertion_point(copy_constructor:MumbleProto.Version)
}
PROTOBUF_NDEBUG_INLINE Version::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        release_(arena),
        os_(arena),
        os_version_(arena) {}

inline void Version::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.version_ = {};
}
Version::~Version() {
  // @@protoc_insertion_point(destructor:MumbleProto.Version)
  SharedDtor(*this);
}
inline void Version::SharedDtor(MessageLite& self) {
  Version& this_ = static_cast<Version&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.release_.Destroy();
  this_._impl_.os_.Destroy();
  this_._impl_.os_version_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Version::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Version(arena);
}
constexpr auto Version::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Version),
                                            alignof(Version));
}
constexpr auto Version::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Version_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Version::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Version>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Version::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Version>(), &Version::ByteSizeLong,
              &Version::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Version, _impl_._cached_size_),
          false,
      },
      &Version::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Version_class_data_ =
        Version::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Version::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Version_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Version_class_data_.tc_table);
  return Version_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
Version::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Version, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Version_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::Version>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string os_version = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 2, 0,
      PROTOBUF_FIELD_OFFSET(Version, _impl_.os_version_)}},
    // optional uint32 version = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Version, _impl_.version_), 3>(),
     {8, 3, 0,
      PROTOBUF_FIELD_OFFSET(Version, _impl_.version_)}},
    // optional string release = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(Version, _impl_.release_)}},
    // optional string os = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(Version, _impl_.os_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 version = 1;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.version_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string release = 2;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.release_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string os = 3;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.os_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string os_version = 4;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.os_version_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.Version)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.release_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.os_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.os_version_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.version_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Version::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Version& this_ = static_cast<const Version&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Version::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Version& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.Version)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_version(), target);
  }

  // optional string release = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_release();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string os = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_os();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string os_version = 4;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_os_version();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.Version)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Version::ByteSizeLong(const MessageLite& base) {
  const Version& this_ = static_cast<const Version&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Version::ByteSizeLong() const {
  const Version& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.Version)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional string release = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_release());
    }
    // optional string os = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_os());
    }
    // optional string os_version = 4;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_os_version());
    }
    // optional uint32 version = 1;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_version());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Version::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<Version*>(&to_msg);
  auto& from = static_cast<const Version&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.Version)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_release(from._internal_release());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_os(from._internal_os());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_os_version(from._internal_os_version());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.version_ = from._impl_.version_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Version::InternalSwap(Version* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.release_, &other->_impl_.release_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.os_, &other->_impl_.os_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.os_version_, &other->_impl_.os_version_, arena);
  swap(_impl_.version_, other->_impl_.version_);
}

::google::protobuf::Metadata Version::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UDPTunnel::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UDPTunnel>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

UDPTunnel::UDPTunnel(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UDPTunnel_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.UDPTunnel)
}
PROTOBUF_NDEBUG_INLINE UDPTunnel::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::UDPTunnel& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        packet_(arena, from.packet_) {}

UDPTunnel::UDPTunnel(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UDPTunnel& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UDPTunnel_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UDPTunnel* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:MumbleProto.UDPTunnel)
}
PROTOBUF_NDEBUG_INLINE UDPTunnel::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        packet_(arena) {}

inline void UDPTunnel::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
UDPTunnel::~UDPTunnel() {
  // @@protoc_insertion_point(destructor:MumbleProto.UDPTunnel)
  SharedDtor(*this);
}
inline void UDPTunnel::SharedDtor(MessageLite& self) {
  UDPTunnel& this_ = static_cast<UDPTunnel&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.packet_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UDPTunnel::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UDPTunnel(arena);
}
constexpr auto UDPTunnel::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(UDPTunnel),
                                            alignof(UDPTunnel));
}
constexpr auto UDPTunnel::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UDPTunnel_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          UDPTunnel::IsInitializedImpl,
          &UDPTunnel::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UDPTunnel>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UDPTunnel::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UDPTunnel>(), &UDPTunnel::ByteSizeLong,
              &UDPTunnel::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_._cached_size_),
          false,
      },
      &UDPTunnel::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UDPTunnel_class_data_ =
        UDPTunnel::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UDPTunnel::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UDPTunnel_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UDPTunnel_class_data_.tc_table);
  return UDPTunnel_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
UDPTunnel::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UDPTunnel_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::UDPTunnel>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // required bytes packet = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_.packet_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required bytes packet = 1;
    {PROTOBUF_FIELD_OFFSET(UDPTunnel, _impl_.packet_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UDPTunnel::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.UDPTunnel)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.packet_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UDPTunnel::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UDPTunnel& this_ = static_cast<const UDPTunnel&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UDPTunnel::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UDPTunnel& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.UDPTunnel)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required bytes packet = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_packet();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.UDPTunnel)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UDPTunnel::ByteSizeLong(const MessageLite& base) {
  const UDPTunnel& this_ = static_cast<const UDPTunnel&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UDPTunnel::ByteSizeLong() const {
  const UDPTunnel& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.UDPTunnel)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // required bytes packet = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_packet());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UDPTunnel::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<UDPTunnel*>(&to_msg);
  auto& from = static_cast<const UDPTunnel&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.UDPTunnel)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_internal_set_packet(from._internal_packet());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void UDPTunnel::CopyFrom(const UDPTunnel& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.UDPTunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UDPTunnel::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UDPTunnel&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void UDPTunnel::InternalSwap(UDPTunnel* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.packet_, &other->_impl_.packet_, arena);
}

::google::protobuf::Metadata UDPTunnel::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Authenticate::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Authenticate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Authenticate, _impl_._has_bits_);
};

Authenticate::Authenticate(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Authenticate_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.Authenticate)
}
PROTOBUF_NDEBUG_INLINE Authenticate::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::Authenticate& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        tokens_{visibility, arena, from.tokens_},
        celt_versions_{visibility, arena, from.celt_versions_},
        username_(arena, from.username_),
        password_(arena, from.password_) {}

Authenticate::Authenticate(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Authenticate& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Authenticate_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Authenticate* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.opus_ = from._impl_.opus_;

  // @@protoc_insertion_point(copy_constructor:MumbleProto.Authenticate)
}
PROTOBUF_NDEBUG_INLINE Authenticate::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        tokens_{visibility, arena},
        celt_versions_{visibility, arena},
        username_(arena),
        password_(arena) {}

inline void Authenticate::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.opus_ = {};
}
Authenticate::~Authenticate() {
  // @@protoc_insertion_point(destructor:MumbleProto.Authenticate)
  SharedDtor(*this);
}
inline void Authenticate::SharedDtor(MessageLite& self) {
  Authenticate& this_ = static_cast<Authenticate&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.username_.Destroy();
  this_._impl_.password_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Authenticate::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Authenticate(arena);
}
constexpr auto Authenticate::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.tokens_) +
          decltype(Authenticate::_impl_.tokens_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.celt_versions_) +
          decltype(Authenticate::_impl_.celt_versions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(Authenticate), alignof(Authenticate), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Authenticate::PlacementNew_,
                                 sizeof(Authenticate),
                                 alignof(Authenticate));
  }
}
constexpr auto Authenticate::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Authenticate_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Authenticate::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Authenticate>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Authenticate::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Authenticate>(), &Authenticate::ByteSizeLong,
              &Authenticate::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Authenticate, _impl_._cached_size_),
          false,
      },
      &Authenticate::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Authenticate_class_data_ =
        Authenticate::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Authenticate::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Authenticate_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Authenticate_class_data_.tc_table);
  return Authenticate_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2>
Authenticate::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Authenticate, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Authenticate_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::Authenticate>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string username = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 2, 0,
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.username_)}},
    // optional string password = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 3, 0,
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.password_)}},
    // repeated string tokens = 3;
    {::_pbi::TcParser::FastBR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.tokens_)}},
    // repeated int32 celt_versions = 4;
    {::_pbi::TcParser::FastV32R1,
     {32, 1, 0,
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.celt_versions_)}},
    // optional bool opus = 5 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Authenticate, _impl_.opus_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.opus_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string username = 1;
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.username_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string password = 2;
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.password_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated string tokens = 3;
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.tokens_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // repeated int32 celt_versions = 4;
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.celt_versions_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // optional bool opus = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(Authenticate, _impl_.opus_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Authenticate::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.Authenticate)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.tokens_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.celt_versions_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.username_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.opus_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Authenticate::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Authenticate& this_ = static_cast<const Authenticate&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Authenticate::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Authenticate& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.Authenticate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string username = 1;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_username();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string password = 2;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_password();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // repeated string tokens = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_tokens_size(); i < n; ++i) {
      const auto& s = this_._internal_tokens().Get(i);
      target = stream->WriteString(3, s, target);
    }
  }

  // repeated int32 celt_versions = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (int i = 0, n = this_._internal_celt_versions_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt32ToArray(
          4, this_._internal_celt_versions().Get(i), target);
    }
  }

  // optional bool opus = 5 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_opus(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.Authenticate)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Authenticate::ByteSizeLong(const MessageLite& base) {
  const Authenticate& this_ = static_cast<const Authenticate&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Authenticate::ByteSizeLong() const {
  const Authenticate& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.Authenticate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000010U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // repeated string tokens = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_tokens().size());
      for (int i = 0, n = this_._internal_tokens().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_tokens().Get(i));
      }
    }
    // repeated int32 celt_versions = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
          this_._internal_celt_versions());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_celt_versions_size());
      total_size += tag_size + data_size;
    }
    // optional string username = 1;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_username());
    }
    // optional string password = 2;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_password());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Authenticate::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<Authenticate*>(&to_msg);
  auto& from = static_cast<const Authenticate&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.Authenticate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_tokens()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_tokens());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_celt_versions()->MergeFrom(from._internal_celt_versions());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_username(from._internal_username());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_password(from._internal_password());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.opus_ = from._impl_.opus_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void Authenticate::CopyFrom(const Authenticate& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.Authenticate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Authenticate::InternalSwap(Authenticate* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
  _impl_.celt_versions_.InternalSwap(&other->_impl_.celt_versions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.username_, &other->_impl_.username_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, &other->_impl_.password_, arena);
  swap(_impl_.opus_, other->_impl_.opus_);
}

::google::protobuf::Metadata Authenticate::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Ping::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Ping>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Ping, _impl_._has_bits_);
};

Ping::Ping(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Ping_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.Ping)
}
Ping::Ping(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Ping& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Ping_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE Ping::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void Ping::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, timestamp_),
           0,
           offsetof(Impl_, tcp_ping_var_) -
               offsetof(Impl_, timestamp_) +
               sizeof(Impl_::tcp_ping_var_));
}
Ping::~Ping() {
  // @@protoc_insertion_point(destructor:MumbleProto.Ping)
  SharedDtor(*this);
}
inline void Ping::SharedDtor(MessageLite& self) {
  Ping& this_ = static_cast<Ping&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Ping::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Ping(arena);
}
constexpr auto Ping::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Ping),
                                            alignof(Ping));
}
constexpr auto Ping::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Ping_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Ping::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Ping>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Ping::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Ping>(), &Ping::ByteSizeLong,
              &Ping::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Ping, _impl_._cached_size_),
          false,
      },
      &Ping::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Ping_class_data_ =
        Ping::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Ping::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Ping_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Ping_class_data_.tc_table);
  return Ping_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 0, 0, 2>
Ping::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Ping, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Ping_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::Ping>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 timestamp = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Ping, _impl_.timestamp_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.timestamp_)}},
    // optional uint32 good = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.good_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.good_)}},
    // optional uint32 late = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.late_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.late_)}},
    // optional uint32 lost = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.lost_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.lost_)}},
    // optional uint32 resync = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.resync_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.resync_)}},
    // optional uint32 udp_packets = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.udp_packets_), 5>(),
     {48, 5, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_packets_)}},
    // optional uint32 tcp_packets = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ping, _impl_.tcp_packets_), 6>(),
     {56, 6, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_packets_)}},
    // optional float udp_ping_avg = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 7, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_ping_avg_)}},
    // optional float udp_ping_var = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 8, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_ping_var_)}},
    // optional float tcp_ping_avg = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 9, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_avg_)}},
    // optional float tcp_ping_var = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 10, 0,
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_var_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 timestamp = 1;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.timestamp_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint32 good = 2;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.good_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 late = 3;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.late_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 lost = 4;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.lost_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 resync = 5;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.resync_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 udp_packets = 6;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_packets_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 tcp_packets = 7;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_packets_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float udp_ping_avg = 8;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_ping_avg_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float udp_ping_var = 9;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.udp_ping_var_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float tcp_ping_avg = 10;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_avg_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float tcp_ping_var = 11;
    {PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_var_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Ping::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.Ping)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    ::memset(&_impl_.timestamp_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.udp_ping_avg_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.udp_ping_avg_));
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000700U)) {
    ::memset(&_impl_.udp_ping_var_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.tcp_ping_var_) -
        reinterpret_cast<char*>(&_impl_.udp_ping_var_)) + sizeof(_impl_.tcp_ping_var_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Ping::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Ping& this_ = static_cast<const Ping&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Ping::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Ping& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.Ping)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint64 timestamp = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this_._internal_timestamp(), target);
  }

  // optional uint32 good = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_good(), target);
  }

  // optional uint32 late = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_late(), target);
  }

  // optional uint32 lost = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_lost(), target);
  }

  // optional uint32 resync = 5;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this_._internal_resync(), target);
  }

  // optional uint32 udp_packets = 6;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_udp_packets(), target);
  }

  // optional uint32 tcp_packets = 7;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_tcp_packets(), target);
  }

  // optional float udp_ping_avg = 8;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this_._internal_udp_ping_avg(), target);
  }

  // optional float udp_ping_var = 9;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this_._internal_udp_ping_var(), target);
  }

  // optional float tcp_ping_avg = 10;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this_._internal_tcp_ping_avg(), target);
  }

  // optional float tcp_ping_var = 11;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this_._internal_tcp_ping_var(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.Ping)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Ping::ByteSizeLong(const MessageLite& base) {
  const Ping& this_ = static_cast<const Ping&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Ping::ByteSizeLong() const {
  const Ping& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.Ping)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000780U & cached_has_bits) * 5;
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    // optional uint64 timestamp = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_timestamp());
    }
    // optional uint32 good = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_good());
    }
    // optional uint32 late = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_late());
    }
    // optional uint32 lost = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_lost());
    }
    // optional uint32 resync = 5;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_resync());
    }
    // optional uint32 udp_packets = 6;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_udp_packets());
    }
    // optional uint32 tcp_packets = 7;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_tcp_packets());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Ping::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<Ping*>(&to_msg);
  auto& from = static_cast<const Ping&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.Ping)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.good_ = from._impl_.good_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.late_ = from._impl_.late_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.lost_ = from._impl_.lost_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.resync_ = from._impl_.resync_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.udp_packets_ = from._impl_.udp_packets_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.tcp_packets_ = from._impl_.tcp_packets_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.udp_ping_avg_ = from._impl_.udp_ping_avg_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000700U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.udp_ping_var_ = from._impl_.udp_ping_var_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.tcp_ping_avg_ = from._impl_.tcp_ping_avg_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.tcp_ping_var_ = from._impl_.tcp_ping_var_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void Ping::CopyFrom(const Ping& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.Ping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Ping::InternalSwap(Ping* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ping, _impl_.tcp_ping_var_)
      + sizeof(Ping::_impl_.tcp_ping_var_)
      - PROTOBUF_FIELD_OFFSET(Ping, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::google::protobuf::Metadata Ping::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Reject::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Reject>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Reject, _impl_._has_bits_);
};

Reject::Reject(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Reject_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.Reject)
}
PROTOBUF_NDEBUG_INLINE Reject::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::Reject& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reason_(arena, from.reason_) {}

Reject::Reject(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Reject& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Reject_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Reject* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.type_ = from._impl_.type_;

  // @@protoc_insertion_point(copy_constructor:MumbleProto.Reject)
}
PROTOBUF_NDEBUG_INLINE Reject::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reason_(arena) {}

inline void Reject::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.type_ = {};
}
Reject::~Reject() {
  // @@protoc_insertion_point(destructor:MumbleProto.Reject)
  SharedDtor(*this);
}
inline void Reject::SharedDtor(MessageLite& self) {
  Reject& this_ = static_cast<Reject&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.reason_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Reject::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Reject(arena);
}
constexpr auto Reject::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Reject),
                                            alignof(Reject));
}
constexpr auto Reject::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Reject_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Reject::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Reject>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Reject::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Reject>(), &Reject::ByteSizeLong,
              &Reject::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Reject, _impl_._cached_size_),
          false,
      },
      &Reject::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Reject_class_data_ =
        Reject::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Reject::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Reject_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Reject_class_data_.tc_table);
  return Reject_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
Reject::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Reject, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    Reject_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::Reject>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional string reason = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(Reject, _impl_.reason_)}},
    // optional .MumbleProto.Reject.RejectType type = 1;
    {::_pbi::TcParser::FastEr0S1,
     {8, 1, 8,
      PROTOBUF_FIELD_OFFSET(Reject, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .MumbleProto.Reject.RejectType type = 1;
    {PROTOBUF_FIELD_OFFSET(Reject, _impl_.type_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string reason = 2;
    {PROTOBUF_FIELD_OFFSET(Reject, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  {{
      {0, 8},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void Reject::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.Reject)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.reason_.ClearNonDefaultToEmpty();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Reject::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Reject& this_ = static_cast<const Reject&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Reject::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Reject& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.Reject)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional .MumbleProto.Reject.RejectType type = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this_._internal_type(), target);
  }

  // optional string reason = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_reason();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.Reject)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Reject::ByteSizeLong(const MessageLite& base) {
  const Reject& this_ = static_cast<const Reject&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Reject::ByteSizeLong() const {
  const Reject& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.Reject)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional string reason = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_reason());
    }
    // optional .MumbleProto.Reject.RejectType type = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Reject::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<Reject*>(&to_msg);
  auto& from = static_cast<const Reject&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.Reject)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.type_ = from._impl_.type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void Reject::CopyFrom(const Reject& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.Reject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Reject::InternalSwap(Reject* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  swap(_impl_.type_, other->_impl_.type_);
}

::google::protobuf::Metadata Reject::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ServerSync::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ServerSync>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ServerSync, _impl_._has_bits_);
};

ServerSync::ServerSync(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ServerSync_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ServerSync)
}
PROTOBUF_NDEBUG_INLINE ServerSync::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::ServerSync& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        welcome_text_(arena, from.welcome_text_) {}

ServerSync::ServerSync(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ServerSync& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ServerSync_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ServerSync* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, permissions_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::permissions_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.ServerSync)
}
PROTOBUF_NDEBUG_INLINE ServerSync::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        welcome_text_(arena) {}

inline void ServerSync::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           0,
           offsetof(Impl_, permissions_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::permissions_));
}
ServerSync::~ServerSync() {
  // @@protoc_insertion_point(destructor:MumbleProto.ServerSync)
  SharedDtor(*this);
}
inline void ServerSync::SharedDtor(MessageLite& self) {
  ServerSync& this_ = static_cast<ServerSync&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.welcome_text_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ServerSync::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ServerSync(arena);
}
constexpr auto ServerSync::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ServerSync),
                                            alignof(ServerSync));
}
constexpr auto ServerSync::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ServerSync_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ServerSync::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ServerSync>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ServerSync::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ServerSync>(), &ServerSync::ByteSizeLong,
              &ServerSync::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ServerSync, _impl_._cached_size_),
          false,
      },
      &ServerSync::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ServerSync_class_data_ =
        ServerSync::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ServerSync::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ServerSync_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ServerSync_class_data_.tc_table);
  return ServerSync_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
ServerSync::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ServerSync, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ServerSync_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ServerSync>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint64 permissions = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(ServerSync, _impl_.permissions_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.permissions_)}},
    // optional uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerSync, _impl_.session_), 1>(),
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.session_)}},
    // optional uint32 max_bandwidth = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerSync, _impl_.max_bandwidth_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.max_bandwidth_)}},
    // optional string welcome_text = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.welcome_text_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.session_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 max_bandwidth = 2;
    {PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.max_bandwidth_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string welcome_text = 3;
    {PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.welcome_text_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint64 permissions = 4;
    {PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.permissions_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ServerSync::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ServerSync)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.welcome_text_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000eU)) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.permissions_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.permissions_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ServerSync::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ServerSync& this_ = static_cast<const ServerSync&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ServerSync::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ServerSync& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ServerSync)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 session = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional uint32 max_bandwidth = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_max_bandwidth(), target);
  }

  // optional string welcome_text = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_welcome_text();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 permissions = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this_._internal_permissions(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ServerSync)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ServerSync::ByteSizeLong(const MessageLite& base) {
  const ServerSync& this_ = static_cast<const ServerSync&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ServerSync::ByteSizeLong() const {
  const ServerSync& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ServerSync)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional string welcome_text = 3;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_welcome_text());
    }
    // optional uint32 session = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional uint32 max_bandwidth = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_max_bandwidth());
    }
    // optional uint64 permissions = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_permissions());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ServerSync::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ServerSync*>(&to_msg);
  auto& from = static_cast<const ServerSync&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ServerSync)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_welcome_text(from._internal_welcome_text());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.max_bandwidth_ = from._impl_.max_bandwidth_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.permissions_ = from._impl_.permissions_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ServerSync::CopyFrom(const ServerSync& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ServerSync)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ServerSync::InternalSwap(ServerSync* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.welcome_text_, &other->_impl_.welcome_text_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.permissions_)
      + sizeof(ServerSync::_impl_.permissions_)
      - PROTOBUF_FIELD_OFFSET(ServerSync, _impl_.session_)>(
          reinterpret_cast<char*>(&_impl_.session_),
          reinterpret_cast<char*>(&other->_impl_.session_));
}

::google::protobuf::Metadata ServerSync::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChannelRemove::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ChannelRemove>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ChannelRemove::ChannelRemove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChannelRemove_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ChannelRemove)
}
ChannelRemove::ChannelRemove(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChannelRemove& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChannelRemove_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE ChannelRemove::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void ChannelRemove::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.channel_id_ = {};
}
ChannelRemove::~ChannelRemove() {
  // @@protoc_insertion_point(destructor:MumbleProto.ChannelRemove)
  SharedDtor(*this);
}
inline void ChannelRemove::SharedDtor(MessageLite& self) {
  ChannelRemove& this_ = static_cast<ChannelRemove&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ChannelRemove::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ChannelRemove(arena);
}
constexpr auto ChannelRemove::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(ChannelRemove),
                                            alignof(ChannelRemove));
}
constexpr auto ChannelRemove::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ChannelRemove_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ChannelRemove::IsInitializedImpl,
          &ChannelRemove::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ChannelRemove>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ChannelRemove::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ChannelRemove>(), &ChannelRemove::ByteSizeLong,
              &ChannelRemove::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_._cached_size_),
          false,
      },
      &ChannelRemove::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ChannelRemove_class_data_ =
        ChannelRemove::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ChannelRemove::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ChannelRemove_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ChannelRemove_class_data_.tc_table);
  return ChannelRemove_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
ChannelRemove::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ChannelRemove_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ChannelRemove>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // required uint32 channel_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelRemove, _impl_.channel_id_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_.channel_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint32 channel_id = 1;
    {PROTOBUF_FIELD_OFFSET(ChannelRemove, _impl_.channel_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ChannelRemove::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ChannelRemove)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.channel_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ChannelRemove::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ChannelRemove& this_ = static_cast<const ChannelRemove&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ChannelRemove::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ChannelRemove& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ChannelRemove)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required uint32 channel_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_channel_id(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ChannelRemove)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ChannelRemove::ByteSizeLong(const MessageLite& base) {
  const ChannelRemove& this_ = static_cast<const ChannelRemove&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ChannelRemove::ByteSizeLong() const {
  const ChannelRemove& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ChannelRemove)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // required uint32 channel_id = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ChannelRemove::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ChannelRemove*>(&to_msg);
  auto& from = static_cast<const ChannelRemove&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ChannelRemove)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _this->_impl_.channel_id_ = from._impl_.channel_id_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ChannelRemove::CopyFrom(const ChannelRemove& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ChannelRemove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ChannelRemove::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ChannelRemove&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ChannelRemove::InternalSwap(ChannelRemove* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.channel_id_, other->_impl_.channel_id_);
}

::google::protobuf::Metadata ChannelRemove::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChannelState::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ChannelState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChannelState, _impl_._has_bits_);
};

ChannelState::ChannelState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChannelState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ChannelState)
}
PROTOBUF_NDEBUG_INLINE ChannelState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::ChannelState& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        links_{visibility, arena, from.links_},
        links_add_{visibility, arena, from.links_add_},
        links_remove_{visibility, arena, from.links_remove_},
        name_(arena, from.name_),
        description_(arena, from.description_),
        description_hash_(arena, from.description_hash_) {}

ChannelState::ChannelState(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ChannelState& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChannelState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ChannelState* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, channel_id_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, channel_id_),
           offsetof(Impl_, max_users_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::max_users_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.ChannelState)
}
PROTOBUF_NDEBUG_INLINE ChannelState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        links_{visibility, arena},
        links_add_{visibility, arena},
        links_remove_{visibility, arena},
        name_(arena),
        description_(arena),
        description_hash_(arena) {}

inline void ChannelState::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, channel_id_),
           0,
           offsetof(Impl_, max_users_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::max_users_));
}
ChannelState::~ChannelState() {
  // @@protoc_insertion_point(destructor:MumbleProto.ChannelState)
  SharedDtor(*this);
}
inline void ChannelState::SharedDtor(MessageLite& self) {
  ChannelState& this_ = static_cast<ChannelState&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.description_.Destroy();
  this_._impl_.description_hash_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ChannelState::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ChannelState(arena);
}
constexpr auto ChannelState::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_) +
          decltype(ChannelState::_impl_.links_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_add_) +
          decltype(ChannelState::_impl_.links_add_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_remove_) +
          decltype(ChannelState::_impl_.links_remove_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ChannelState), alignof(ChannelState), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ChannelState::PlacementNew_,
                                 sizeof(ChannelState),
                                 alignof(ChannelState));
  }
}
constexpr auto ChannelState::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ChannelState_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ChannelState::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ChannelState>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ChannelState::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ChannelState>(), &ChannelState::ByteSizeLong,
              &ChannelState::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ChannelState, _impl_._cached_size_),
          false,
      },
      &ChannelState::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ChannelState_class_data_ =
        ChannelState::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ChannelState::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ChannelState_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ChannelState_class_data_.tc_table);
  return ChannelState_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 0, 0, 2>
ChannelState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChannelState, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ChannelState_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ChannelState>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 channel_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelState, _impl_.channel_id_), 6>(),
     {8, 6, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.channel_id_)}},
    // optional uint32 parent = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelState, _impl_.parent_), 7>(),
     {16, 7, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.parent_)}},
    // optional string name = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 3, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.name_)}},
    // repeated uint32 links = 4;
    {::_pbi::TcParser::FastV32R1,
     {32, 0, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_)}},
    // optional string description = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 4, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.description_)}},
    // repeated uint32 links_add = 6;
    {::_pbi::TcParser::FastV32R1,
     {48, 1, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_add_)}},
    // repeated uint32 links_remove = 7;
    {::_pbi::TcParser::FastV32R1,
     {56, 2, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_remove_)}},
    // optional bool temporary = 8 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ChannelState, _impl_.temporary_), 8>(),
     {64, 8, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.temporary_)}},
    // optional int32 position = 9 [default = 0];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelState, _impl_.position_), 9>(),
     {72, 9, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.position_)}},
    // optional bytes description_hash = 10;
    {::_pbi::TcParser::FastBS1,
     {82, 5, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.description_hash_)}},
    // optional uint32 max_users = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChannelState, _impl_.max_users_), 10>(),
     {88, 10, 0,
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.max_users_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 channel_id = 1;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.channel_id_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 parent = 2;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.parent_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string name = 3;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.name_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated uint32 links = 4;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // optional string description = 5;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.description_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated uint32 links_add = 6;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_add_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 links_remove = 7;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.links_remove_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // optional bool temporary = 8 [default = false];
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.temporary_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional int32 position = 9 [default = 0];
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.position_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bytes description_hash = 10;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.description_hash_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 max_users = 11;
    {PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.max_users_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ChannelState::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ChannelState)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.links_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.links_add_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.links_remove_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _impl_.description_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000c0U)) {
    ::memset(&_impl_.channel_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.parent_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.parent_));
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000700U)) {
    ::memset(&_impl_.temporary_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_users_) -
        reinterpret_cast<char*>(&_impl_.temporary_)) + sizeof(_impl_.max_users_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ChannelState::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ChannelState& this_ = static_cast<const ChannelState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ChannelState::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ChannelState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ChannelState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 channel_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_channel_id(), target);
  }

  // optional uint32 parent = 2;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_parent(), target);
  }

  // optional string name = 3;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_name();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // repeated uint32 links = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_links_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          4, this_._internal_links().Get(i), target);
    }
  }

  // optional string description = 5;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    const ::std::string& _s = this_._internal_description();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // repeated uint32 links_add = 6;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (int i = 0, n = this_._internal_links_add_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          6, this_._internal_links_add().Get(i), target);
    }
  }

  // repeated uint32 links_remove = 7;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (int i = 0, n = this_._internal_links_remove_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          7, this_._internal_links_remove().Get(i), target);
    }
  }

  // optional bool temporary = 8 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_temporary(), target);
  }

  // optional int32 position = 9 [default = 0];
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<9>(
            stream, this_._internal_position(), target);
  }

  // optional bytes description_hash = 10;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    const ::std::string& _s = this_._internal_description_hash();
    target = stream->WriteBytesMaybeAliased(10, _s, target);
  }

  // optional uint32 max_users = 11;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this_._internal_max_users(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ChannelState)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ChannelState::ByteSizeLong(const MessageLite& base) {
  const ChannelState& this_ = static_cast<const ChannelState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ChannelState::ByteSizeLong() const {
  const ChannelState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ChannelState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000100U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated uint32 links = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_links());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_links_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 links_add = 6;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_links_add());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_links_add_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 links_remove = 7;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_links_remove());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_links_remove_size());
      total_size += tag_size + data_size;
    }
    // optional string name = 3;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional string description = 5;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_description());
    }
    // optional bytes description_hash = 10;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_description_hash());
    }
    // optional uint32 channel_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
    // optional uint32 parent = 2;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_parent());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000600U)) {
    // optional int32 position = 9 [default = 0];
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_position());
    }
    // optional uint32 max_users = 11;
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_max_users());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ChannelState::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ChannelState*>(&to_msg);
  auto& from = static_cast<const ChannelState&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ChannelState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_links()->MergeFrom(from._internal_links());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_links_add()->MergeFrom(from._internal_links_add());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_links_remove()->MergeFrom(from._internal_links_remove());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_name(from._internal_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_internal_set_description(from._internal_description());
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_internal_set_description_hash(from._internal_description_hash());
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.parent_ = from._impl_.parent_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000700U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.temporary_ = from._impl_.temporary_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.position_ = from._impl_.position_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.max_users_ = from._impl_.max_users_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ChannelState::CopyFrom(const ChannelState& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ChannelState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ChannelState::InternalSwap(ChannelState* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.links_.InternalSwap(&other->_impl_.links_);
  _impl_.links_add_.InternalSwap(&other->_impl_.links_add_);
  _impl_.links_remove_.InternalSwap(&other->_impl_.links_remove_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_hash_, &other->_impl_.description_hash_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.max_users_)
      + sizeof(ChannelState::_impl_.max_users_)
      - PROTOBUF_FIELD_OFFSET(ChannelState, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::google::protobuf::Metadata ChannelState::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserRemove::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserRemove>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserRemove, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

UserRemove::UserRemove(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserRemove_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.UserRemove)
}
PROTOBUF_NDEBUG_INLINE UserRemove::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::UserRemove& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reason_(arena, from.reason_) {}

UserRemove::UserRemove(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserRemove& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserRemove_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserRemove* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, ban_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::ban_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.UserRemove)
}
PROTOBUF_NDEBUG_INLINE UserRemove::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reason_(arena) {}

inline void UserRemove::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           0,
           offsetof(Impl_, ban_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::ban_));
}
UserRemove::~UserRemove() {
  // @@protoc_insertion_point(destructor:MumbleProto.UserRemove)
  SharedDtor(*this);
}
inline void UserRemove::SharedDtor(MessageLite& self) {
  UserRemove& this_ = static_cast<UserRemove&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.reason_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserRemove::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserRemove(arena);
}
constexpr auto UserRemove::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(UserRemove),
                                            alignof(UserRemove));
}
constexpr auto UserRemove::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserRemove_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          UserRemove::IsInitializedImpl,
          &UserRemove::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserRemove>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserRemove::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserRemove>(), &UserRemove::ByteSizeLong,
              &UserRemove::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserRemove, _impl_._cached_size_),
          false,
      },
      &UserRemove::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserRemove_class_data_ =
        UserRemove::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserRemove::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserRemove_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserRemove_class_data_.tc_table);
  return UserRemove_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
UserRemove::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserRemove, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UserRemove_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::UserRemove>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool ban = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserRemove, _impl_.ban_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_)}},
    // required uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserRemove, _impl_.session_), 1>(),
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.session_)}},
    // optional uint32 actor = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserRemove, _impl_.actor_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.actor_)}},
    // optional string reason = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.reason_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.session_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 actor = 2;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.actor_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string reason = 3;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool ban = 4;
    {PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UserRemove::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.UserRemove)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.reason_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000eU)) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ban_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.ban_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserRemove::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserRemove& this_ = static_cast<const UserRemove&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserRemove::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserRemove& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.UserRemove)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required uint32 session = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional uint32 actor = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_actor(), target);
  }

  // optional string reason = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_reason();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional bool ban = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_ban(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.UserRemove)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserRemove::ByteSizeLong(const MessageLite& base) {
  const UserRemove& this_ = static_cast<const UserRemove&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserRemove::ByteSizeLong() const {
  const UserRemove& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.UserRemove)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000008U & cached_has_bits) * 2;
   {
    // optional string reason = 3;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_reason());
    }
  }
   {
    // required uint32 session = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
  }
   {
    // optional uint32 actor = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_actor());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserRemove::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<UserRemove*>(&to_msg);
  auto& from = static_cast<const UserRemove&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.UserRemove)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.actor_ = from._impl_.actor_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.ban_ = from._impl_.ban_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void UserRemove::CopyFrom(const UserRemove& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.UserRemove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UserRemove::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UserRemove&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void UserRemove::InternalSwap(UserRemove* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.ban_)
      + sizeof(UserRemove::_impl_.ban_)
      - PROTOBUF_FIELD_OFFSET(UserRemove, _impl_.session_)>(
          reinterpret_cast<char*>(&_impl_.session_),
          reinterpret_cast<char*>(&other->_impl_.session_));
}

::google::protobuf::Metadata UserRemove::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserState::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserState, _impl_._has_bits_);
};

UserState::UserState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.UserState)
}
PROTOBUF_NDEBUG_INLINE UserState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::UserState& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        name_(arena, from.name_),
        texture_(arena, from.texture_),
        plugin_context_(arena, from.plugin_context_),
        plugin_identity_(arena, from.plugin_identity_),
        comment_(arena, from.comment_),
        hash_(arena, from.hash_),
        comment_hash_(arena, from.comment_hash_),
        texture_hash_(arena, from.texture_hash_) {}

UserState::UserState(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserState& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserState_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserState* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, recording_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::recording_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.UserState)
}
PROTOBUF_NDEBUG_INLINE UserState::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        name_(arena),
        texture_(arena),
        plugin_context_(arena),
        plugin_identity_(arena),
        comment_(arena),
        hash_(arena),
        comment_hash_(arena),
        texture_hash_(arena) {}

inline void UserState::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           0,
           offsetof(Impl_, recording_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::recording_));
}
UserState::~UserState() {
  // @@protoc_insertion_point(destructor:MumbleProto.UserState)
  SharedDtor(*this);
}
inline void UserState::SharedDtor(MessageLite& self) {
  UserState& this_ = static_cast<UserState&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.texture_.Destroy();
  this_._impl_.plugin_context_.Destroy();
  this_._impl_.plugin_identity_.Destroy();
  this_._impl_.comment_.Destroy();
  this_._impl_.hash_.Destroy();
  this_._impl_.comment_hash_.Destroy();
  this_._impl_.texture_hash_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserState::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserState(arena);
}
constexpr auto UserState::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(UserState),
                                            alignof(UserState));
}
constexpr auto UserState::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserState_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UserState::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserState>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserState::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserState>(), &UserState::ByteSizeLong,
              &UserState::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserState, _impl_._cached_size_),
          false,
      },
      &UserState::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserState_class_data_ =
        UserState::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserState::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserState_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserState_class_data_.tc_table);
  return UserState_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 19, 0, 0, 2>
UserState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserState, _impl_._has_bits_),
    0, // no _extensions_
    19, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294443008,  // skipmap
    offsetof(decltype(_table_), field_entries),
    19,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UserState_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::UserState>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState, _impl_.session_), 8>(),
     {8, 8, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.session_)}},
    // optional uint32 actor = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState, _impl_.actor_), 9>(),
     {16, 9, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.actor_)}},
    // optional string name = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.name_)}},
    // optional uint32 user_id = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState, _impl_.user_id_), 10>(),
     {32, 10, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.user_id_)}},
    // optional uint32 channel_id = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserState, _impl_.channel_id_), 11>(),
     {40, 11, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.channel_id_)}},
    // optional bool mute = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.mute_), 12>(),
     {48, 12, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.mute_)}},
    // optional bool deaf = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.deaf_), 13>(),
     {56, 13, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.deaf_)}},
    // optional bool suppress = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.suppress_), 14>(),
     {64, 14, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.suppress_)}},
    // optional bool self_mute = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.self_mute_), 15>(),
     {72, 15, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.self_mute_)}},
    // optional bool self_deaf = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserState, _impl_.self_deaf_), 16>(),
     {80, 16, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.self_deaf_)}},
    // optional bytes texture = 11;
    {::_pbi::TcParser::FastBS1,
     {90, 1, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.texture_)}},
    // optional bytes plugin_context = 12;
    {::_pbi::TcParser::FastBS1,
     {98, 2, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.plugin_context_)}},
    // optional string plugin_identity = 13;
    {::_pbi::TcParser::FastBS1,
     {106, 3, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.plugin_identity_)}},
    // optional string comment = 14;
    {::_pbi::TcParser::FastBS1,
     {114, 4, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.comment_)}},
    // optional string hash = 15;
    {::_pbi::TcParser::FastBS1,
     {122, 5, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.hash_)}},
    // optional bytes comment_hash = 16;
    {::_pbi::TcParser::FastBS2,
     {386, 6, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.comment_hash_)}},
    // optional bytes texture_hash = 17;
    {::_pbi::TcParser::FastBS2,
     {394, 7, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.texture_hash_)}},
    // optional bool priority_speaker = 18;
    {::_pbi::TcParser::FastV8S2,
     {400, 17, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.priority_speaker_)}},
    // optional bool recording = 19;
    {::_pbi::TcParser::FastV8S2,
     {408, 18, 0,
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.recording_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.session_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 actor = 2;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.actor_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string name = 3;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.name_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 user_id = 4;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.user_id_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 channel_id = 5;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.channel_id_), _Internal::kHasBitsOffset + 11, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool mute = 6;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.mute_), _Internal::kHasBitsOffset + 12, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool deaf = 7;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.deaf_), _Internal::kHasBitsOffset + 13, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool suppress = 8;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.suppress_), _Internal::kHasBitsOffset + 14, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool self_mute = 9;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.self_mute_), _Internal::kHasBitsOffset + 15, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool self_deaf = 10;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.self_deaf_), _Internal::kHasBitsOffset + 16, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bytes texture = 11;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.texture_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes plugin_context = 12;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.plugin_context_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string plugin_identity = 13;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.plugin_identity_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string comment = 14;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.comment_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string hash = 15;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.hash_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes comment_hash = 16;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.comment_hash_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes texture_hash = 17;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.texture_hash_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool priority_speaker = 18;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.priority_speaker_), _Internal::kHasBitsOffset + 17, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool recording = 19;
    {PROTOBUF_FIELD_OFFSET(UserState, _impl_.recording_), _Internal::kHasBitsOffset + 18, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UserState::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.UserState)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.texture_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.plugin_context_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.plugin_identity_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.comment_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _impl_.hash_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _impl_.comment_hash_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _impl_.texture_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.self_mute_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.self_mute_));
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00070000U)) {
    ::memset(&_impl_.self_deaf_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.recording_) -
        reinterpret_cast<char*>(&_impl_.self_deaf_)) + sizeof(_impl_.recording_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserState::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserState& this_ = static_cast<const UserState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserState::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.UserState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 session = 1;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional uint32 actor = 2;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_actor(), target);
  }

  // optional string name = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_name();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint32 user_id = 4;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_user_id(), target);
  }

  // optional uint32 channel_id = 5;
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this_._internal_channel_id(), target);
  }

  // optional bool mute = 6;
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this_._internal_mute(), target);
  }

  // optional bool deaf = 7;
  if (CheckHasBit(cached_has_bits, 0x00002000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this_._internal_deaf(), target);
  }

  // optional bool suppress = 8;
  if (CheckHasBit(cached_has_bits, 0x00004000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this_._internal_suppress(), target);
  }

  // optional bool self_mute = 9;
  if (CheckHasBit(cached_has_bits, 0x00008000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this_._internal_self_mute(), target);
  }

  // optional bool self_deaf = 10;
  if (CheckHasBit(cached_has_bits, 0x00010000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this_._internal_self_deaf(), target);
  }

  // optional bytes texture = 11;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_texture();
    target = stream->WriteBytesMaybeAliased(11, _s, target);
  }

  // optional bytes plugin_context = 12;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_plugin_context();
    target = stream->WriteBytesMaybeAliased(12, _s, target);
  }

  // optional string plugin_identity = 13;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_plugin_identity();
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // optional string comment = 14;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    const ::std::string& _s = this_._internal_comment();
    target = stream->WriteStringMaybeAliased(14, _s, target);
  }

  // optional string hash = 15;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    const ::std::string& _s = this_._internal_hash();
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  // optional bytes comment_hash = 16;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    const ::std::string& _s = this_._internal_comment_hash();
    target = stream->WriteBytesMaybeAliased(16, _s, target);
  }

  // optional bytes texture_hash = 17;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    const ::std::string& _s = this_._internal_texture_hash();
    target = stream->WriteBytesMaybeAliased(17, _s, target);
  }

  // optional bool priority_speaker = 18;
  if (CheckHasBit(cached_has_bits, 0x00020000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this_._internal_priority_speaker(), target);
  }

  // optional bool recording = 19;
  if (CheckHasBit(cached_has_bits, 0x00040000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        19, this_._internal_recording(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.UserState)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserState::ByteSizeLong(const MessageLite& base) {
  const UserState& this_ = static_cast<const UserState&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserState::ByteSizeLong() const {
  const UserState& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.UserState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00060000U & cached_has_bits) * 3;
  total_size += ::absl::popcount(0x0001f000U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // optional string name = 3;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional bytes texture = 11;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_texture());
    }
    // optional bytes plugin_context = 12;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_plugin_context());
    }
    // optional string plugin_identity = 13;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_plugin_identity());
    }
    // optional string comment = 14;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_comment());
    }
    // optional string hash = 15;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_hash());
    }
    // optional bytes comment_hash = 16;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_comment_hash());
    }
    // optional bytes texture_hash = 17;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_texture_hash());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000f00U)) {
    // optional uint32 session = 1;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional uint32 actor = 2;
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_actor());
    }
    // optional uint32 user_id = 4;
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_user_id());
    }
    // optional uint32 channel_id = 5;
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserState::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<UserState*>(&to_msg);
  auto& from = static_cast<const UserState&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.UserState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_name(from._internal_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_texture(from._internal_texture());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_plugin_context(from._internal_plugin_context());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_plugin_identity(from._internal_plugin_identity());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_internal_set_comment(from._internal_comment());
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_internal_set_comment_hash(from._internal_comment_hash());
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_internal_set_texture_hash(from._internal_texture_hash());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.actor_ = from._impl_.actor_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _this->_impl_.mute_ = from._impl_.mute_;
    }
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      _this->_impl_.deaf_ = from._impl_.deaf_;
    }
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      _this->_impl_.suppress_ = from._impl_.suppress_;
    }
    if (CheckHasBit(cached_has_bits, 0x00008000U)) {
      _this->_impl_.self_mute_ = from._impl_.self_mute_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00070000U)) {
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      _this->_impl_.self_deaf_ = from._impl_.self_deaf_;
    }
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      _this->_impl_.priority_speaker_ = from._impl_.priority_speaker_;
    }
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      _this->_impl_.recording_ = from._impl_.recording_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void UserState::CopyFrom(const UserState& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.UserState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UserState::InternalSwap(UserState* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.texture_, &other->_impl_.texture_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.plugin_context_, &other->_impl_.plugin_context_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.plugin_identity_, &other->_impl_.plugin_identity_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comment_, &other->_impl_.comment_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_, &other->_impl_.hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.comment_hash_, &other->_impl_.comment_hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.texture_hash_, &other->_impl_.texture_hash_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserState, _impl_.recording_)
      + sizeof(UserState::_impl_.recording_)
      - PROTOBUF_FIELD_OFFSET(UserState, _impl_.session_)>(
          reinterpret_cast<char*>(&_impl_.session_),
          reinterpret_cast<char*>(&other->_impl_.session_));
}

::google::protobuf::Metadata UserState::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BanList_BanEntry::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BanList_BanEntry>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000021) ^ 0x00000021) != 0;
  }
};

BanList_BanEntry::BanList_BanEntry(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BanList_BanEntry_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.BanList.BanEntry)
}
PROTOBUF_NDEBUG_INLINE BanList_BanEntry::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::BanList_BanEntry& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        address_(arena, from.address_),
        name_(arena, from.name_),
        hash_(arena, from.hash_),
        reason_(arena, from.reason_),
        start_(arena, from.start_) {}

BanList_BanEntry::BanList_BanEntry(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BanList_BanEntry& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BanList_BanEntry_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BanList_BanEntry* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, mask_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, mask_),
           offsetof(Impl_, duration_) -
               offsetof(Impl_, mask_) +
               sizeof(Impl_::duration_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.BanList.BanEntry)
}
PROTOBUF_NDEBUG_INLINE BanList_BanEntry::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        address_(arena),
        name_(arena),
        hash_(arena),
        reason_(arena),
        start_(arena) {}

inline void BanList_BanEntry::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, mask_),
           0,
           offsetof(Impl_, duration_) -
               offsetof(Impl_, mask_) +
               sizeof(Impl_::duration_));
}
BanList_BanEntry::~BanList_BanEntry() {
  // @@protoc_insertion_point(destructor:MumbleProto.BanList.BanEntry)
  SharedDtor(*this);
}
inline void BanList_BanEntry::SharedDtor(MessageLite& self) {
  BanList_BanEntry& this_ = static_cast<BanList_BanEntry&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.address_.Destroy();
  this_._impl_.name_.Destroy();
  this_._impl_.hash_.Destroy();
  this_._impl_.reason_.Destroy();
  this_._impl_.start_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BanList_BanEntry::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BanList_BanEntry(arena);
}
constexpr auto BanList_BanEntry::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(BanList_BanEntry),
                                            alignof(BanList_BanEntry));
}
constexpr auto BanList_BanEntry::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_BanList_BanEntry_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          BanList_BanEntry::IsInitializedImpl,
          &BanList_BanEntry::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<BanList_BanEntry>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BanList_BanEntry::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<BanList_BanEntry>(), &BanList_BanEntry::ByteSizeLong,
              &BanList_BanEntry::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_._cached_size_),
          false,
      },
      &BanList_BanEntry::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull BanList_BanEntry_class_data_ =
        BanList_BanEntry::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BanList_BanEntry::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&BanList_BanEntry_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(BanList_BanEntry_class_data_.tc_table);
  return BanList_BanEntry_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 2>
BanList_BanEntry::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    BanList_BanEntry_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::BanList_BanEntry>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required bytes address = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.address_)}},
    // required uint32 mask = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(BanList_BanEntry, _impl_.mask_), 5>(),
     {16, 5, 0,
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.mask_)}},
    // optional string name = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.name_)}},
    // optional string hash = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 2, 0,
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.hash_)}},
    // optional string reason = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 3, 0,
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.reason_)}},
    // optional string start = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 4, 0,
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.start_)}},
    // optional uint32 duration = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(BanList_BanEntry, _impl_.duration_), 6>(),
     {56, 6, 0,
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.duration_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required bytes address = 1;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.address_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // required uint32 mask = 2;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.mask_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string name = 3;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.name_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string hash = 4;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.hash_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string reason = 5;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.reason_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string start = 6;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.start_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 duration = 7;
    {PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.duration_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void BanList_BanEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.BanList.BanEntry)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.hash_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _impl_.start_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000060U)) {
    ::memset(&_impl_.mask_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.duration_) -
        reinterpret_cast<char*>(&_impl_.mask_)) + sizeof(_impl_.duration_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BanList_BanEntry::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BanList_BanEntry& this_ = static_cast<const BanList_BanEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BanList_BanEntry::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BanList_BanEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.BanList.BanEntry)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required bytes address = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_address();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // required uint32 mask = 2;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_mask(), target);
  }

  // optional string name = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_name();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string hash = 4;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_hash();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional string reason = 5;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_reason();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string start = 6;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    const ::std::string& _s = this_._internal_start();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional uint32 duration = 7;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_duration(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.BanList.BanEntry)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BanList_BanEntry::ByteSizeLong(const MessageLite& base) {
  const BanList_BanEntry& this_ = static_cast<const BanList_BanEntry&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BanList_BanEntry::ByteSizeLong() const {
  const BanList_BanEntry& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.BanList.BanEntry)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // required bytes address = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_address());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000001eU)) {
    // optional string name = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional string hash = 4;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_hash());
    }
    // optional string reason = 5;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_reason());
    }
    // optional string start = 6;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_start());
    }
  }
   {
    // required uint32 mask = 2;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_mask());
    }
  }
   {
    // optional uint32 duration = 7;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_duration());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void BanList_BanEntry::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BanList_BanEntry*>(&to_msg);
  auto& from = static_cast<const BanList_BanEntry&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.BanList.BanEntry)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_address(from._internal_address());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_name(from._internal_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_hash(from._internal_hash());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_internal_set_start(from._internal_start());
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void BanList_BanEntry::CopyFrom(const BanList_BanEntry& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.BanList.BanEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BanList_BanEntry::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const BanList_BanEntry&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void BanList_BanEntry::InternalSwap(BanList_BanEntry* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.address_, &other->_impl_.address_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash_, &other->_impl_.hash_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_, &other->_impl_.start_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.duration_)
      + sizeof(BanList_BanEntry::_impl_.duration_)
      - PROTOBUF_FIELD_OFFSET(BanList_BanEntry, _impl_.mask_)>(
          reinterpret_cast<char*>(&_impl_.mask_),
          reinterpret_cast<char*>(&other->_impl_.mask_));
}

::google::protobuf::Metadata BanList_BanEntry::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class BanList::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<BanList>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(BanList, _impl_._has_bits_);
};

BanList::BanList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BanList_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.BanList)
}
PROTOBUF_NDEBUG_INLINE BanList::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::BanList& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        bans_{visibility, arena, from.bans_} {}

BanList::BanList(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const BanList& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, BanList_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  BanList* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.query_ = from._impl_.query_;

  // @@protoc_insertion_point(copy_constructor:MumbleProto.BanList)
}
PROTOBUF_NDEBUG_INLINE BanList::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        bans_{visibility, arena} {}

inline void BanList::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.query_ = {};
}
BanList::~BanList() {
  // @@protoc_insertion_point(destructor:MumbleProto.BanList)
  SharedDtor(*this);
}
inline void BanList::SharedDtor(MessageLite& self) {
  BanList& this_ = static_cast<BanList&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL BanList::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) BanList(arena);
}
constexpr auto BanList::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(BanList, _impl_.bans_) +
          decltype(BanList::_impl_.bans_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(BanList), alignof(BanList), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&BanList::PlacementNew_,
                                 sizeof(BanList),
                                 alignof(BanList));
  }
}
constexpr auto BanList::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_BanList_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          BanList::IsInitializedImpl,
          &BanList::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<BanList>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &BanList::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<BanList>(), &BanList::ByteSizeLong,
              &BanList::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(BanList, _impl_._cached_size_),
          false,
      },
      &BanList::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull BanList_class_data_ =
        BanList::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
BanList::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&BanList_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(BanList_class_data_.tc_table);
  return BanList_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
BanList::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BanList, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    BanList_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::BanList>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool query = 2 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(BanList, _impl_.query_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(BanList, _impl_.query_)}},
    // repeated .MumbleProto.BanList.BanEntry bans = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(BanList, _impl_.bans_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .MumbleProto.BanList.BanEntry bans = 1;
    {PROTOBUF_FIELD_OFFSET(BanList, _impl_.bans_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool query = 2 [default = false];
    {PROTOBUF_FIELD_OFFSET(BanList, _impl_.query_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::MumbleProto::BanList_BanEntry>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void BanList::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.BanList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.bans_.Clear();
  }
  _impl_.query_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL BanList::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const BanList& this_ = static_cast<const BanList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL BanList::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const BanList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.BanList)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .MumbleProto.BanList.BanEntry bans = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_bans_size());
         i < n; i++) {
      const auto& repfield = this_._internal_bans().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              1, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // optional bool query = 2 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_query(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.BanList)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t BanList::ByteSizeLong(const MessageLite& base) {
  const BanList& this_ = static_cast<const BanList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t BanList::ByteSizeLong() const {
  const BanList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.BanList)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000002U & cached_has_bits) * 2;
   {
    // repeated .MumbleProto.BanList.BanEntry bans = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_bans_size();
      for (const auto& msg : this_._internal_bans()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void BanList::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<BanList*>(&to_msg);
  auto& from = static_cast<const BanList&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.BanList)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_bans()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_bans());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.query_ = from._impl_.query_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void BanList::CopyFrom(const BanList& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.BanList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BanList::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const BanList&>(msg);
  if (!::google::protobuf::internal::AllAreInitialized(this_._internal_bans()))
    return false;
  return true;
}

void BanList::InternalSwap(BanList* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.bans_.InternalSwap(&other->_impl_.bans_);
  swap(_impl_.query_, other->_impl_.query_);
}

::google::protobuf::Metadata BanList::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class TextMessage::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<TextMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(TextMessage, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

TextMessage::TextMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TextMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.TextMessage)
}
PROTOBUF_NDEBUG_INLINE TextMessage::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::TextMessage& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        session_{visibility, arena, from.session_},
        channel_id_{visibility, arena, from.channel_id_},
        tree_id_{visibility, arena, from.tree_id_},
        message_(arena, from.message_) {}

TextMessage::TextMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const TextMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, TextMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  TextMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.actor_ = from._impl_.actor_;

  // @@protoc_insertion_point(copy_constructor:MumbleProto.TextMessage)
}
PROTOBUF_NDEBUG_INLINE TextMessage::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        session_{visibility, arena},
        channel_id_{visibility, arena},
        tree_id_{visibility, arena},
        message_(arena) {}

inline void TextMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.actor_ = {};
}
TextMessage::~TextMessage() {
  // @@protoc_insertion_point(destructor:MumbleProto.TextMessage)
  SharedDtor(*this);
}
inline void TextMessage::SharedDtor(MessageLite& self) {
  TextMessage& this_ = static_cast<TextMessage&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.message_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL TextMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) TextMessage(arena);
}
constexpr auto TextMessage::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.session_) +
          decltype(TextMessage::_impl_.session_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.channel_id_) +
          decltype(TextMessage::_impl_.channel_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.tree_id_) +
          decltype(TextMessage::_impl_.tree_id_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(TextMessage), alignof(TextMessage), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&TextMessage::PlacementNew_,
                                 sizeof(TextMessage),
                                 alignof(TextMessage));
  }
}
constexpr auto TextMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_TextMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          TextMessage::IsInitializedImpl,
          &TextMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<TextMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &TextMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<TextMessage>(), &TextMessage::ByteSizeLong,
              &TextMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(TextMessage, _impl_._cached_size_),
          false,
      },
      &TextMessage::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull TextMessage_class_data_ =
        TextMessage::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
TextMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&TextMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(TextMessage_class_data_.tc_table);
  return TextMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2>
TextMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TextMessage, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    TextMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::TextMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 actor = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(TextMessage, _impl_.actor_), 4>(),
     {8, 4, 0,
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.actor_)}},
    // repeated uint32 session = 2;
    {::_pbi::TcParser::FastV32R1,
     {16, 0, 0,
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.session_)}},
    // repeated uint32 channel_id = 3;
    {::_pbi::TcParser::FastV32R1,
     {24, 1, 0,
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.channel_id_)}},
    // repeated uint32 tree_id = 4;
    {::_pbi::TcParser::FastV32R1,
     {32, 2, 0,
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.tree_id_)}},
    // required string message = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 3, 0,
      PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.message_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 actor = 1;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.actor_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // repeated uint32 session = 2;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.session_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 channel_id = 3;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.channel_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 tree_id = 4;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.tree_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // required string message = 5;
    {PROTOBUF_FIELD_OFFSET(TextMessage, _impl_.message_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void TextMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.TextMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.session_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.channel_id_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.tree_id_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.actor_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL TextMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const TextMessage& this_ = static_cast<const TextMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL TextMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const TextMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.TextMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 actor = 1;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_actor(), target);
  }

  // repeated uint32 session = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_session_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this_._internal_session().Get(i), target);
    }
  }

  // repeated uint32 channel_id = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (int i = 0, n = this_._internal_channel_id_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this_._internal_channel_id().Get(i), target);
    }
  }

  // repeated uint32 tree_id = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (int i = 0, n = this_._internal_tree_id_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          4, this_._internal_tree_id().Get(i), target);
    }
  }

  // required string message = 5;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_message();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.TextMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t TextMessage::ByteSizeLong(const MessageLite& base) {
  const TextMessage& this_ = static_cast<const TextMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t TextMessage::ByteSizeLong() const {
  const TextMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.TextMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated uint32 session = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_session());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_session_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 channel_id = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_channel_id());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_channel_id_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 tree_id = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_tree_id());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_tree_id_size());
      total_size += tag_size + data_size;
    }
  }
   {
    // required string message = 5;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_message());
    }
  }
   {
    // optional uint32 actor = 1;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_actor());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void TextMessage::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<TextMessage*>(&to_msg);
  auto& from = static_cast<const TextMessage&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.TextMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_session()->MergeFrom(from._internal_session());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_channel_id()->MergeFrom(from._internal_channel_id());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_tree_id()->MergeFrom(from._internal_tree_id());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_message(from._internal_message());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.actor_ = from._impl_.actor_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void TextMessage::CopyFrom(const TextMessage& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.TextMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TextMessage::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const TextMessage&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void TextMessage::InternalSwap(TextMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.session_.InternalSwap(&other->_impl_.session_);
  _impl_.channel_id_.InternalSwap(&other->_impl_.channel_id_);
  _impl_.tree_id_.InternalSwap(&other->_impl_.tree_id_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  swap(_impl_.actor_, other->_impl_.actor_);
}

::google::protobuf::Metadata TextMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PermissionDenied::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PermissionDenied>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_._has_bits_);
};

PermissionDenied::PermissionDenied(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PermissionDenied_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.PermissionDenied)
}
PROTOBUF_NDEBUG_INLINE PermissionDenied::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::PermissionDenied& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        reason_(arena, from.reason_),
        name_(arena, from.name_) {}

PermissionDenied::PermissionDenied(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const PermissionDenied& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PermissionDenied_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  PermissionDenied* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, permission_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, permission_),
           offsetof(Impl_, type_) -
               offsetof(Impl_, permission_) +
               sizeof(Impl_::type_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.PermissionDenied)
}
PROTOBUF_NDEBUG_INLINE PermissionDenied::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        reason_(arena),
        name_(arena) {}

inline void PermissionDenied::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, permission_),
           0,
           offsetof(Impl_, type_) -
               offsetof(Impl_, permission_) +
               sizeof(Impl_::type_));
}
PermissionDenied::~PermissionDenied() {
  // @@protoc_insertion_point(destructor:MumbleProto.PermissionDenied)
  SharedDtor(*this);
}
inline void PermissionDenied::SharedDtor(MessageLite& self) {
  PermissionDenied& this_ = static_cast<PermissionDenied&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.reason_.Destroy();
  this_._impl_.name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PermissionDenied::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PermissionDenied(arena);
}
constexpr auto PermissionDenied::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(PermissionDenied),
                                            alignof(PermissionDenied));
}
constexpr auto PermissionDenied::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PermissionDenied_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PermissionDenied::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PermissionDenied>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PermissionDenied::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PermissionDenied>(), &PermissionDenied::ByteSizeLong,
              &PermissionDenied::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_._cached_size_),
          false,
      },
      &PermissionDenied::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PermissionDenied_class_data_ =
        PermissionDenied::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PermissionDenied::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PermissionDenied_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PermissionDenied_class_data_.tc_table);
  return PermissionDenied_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 0, 2>
PermissionDenied::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    PermissionDenied_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::PermissionDenied>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 permission = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionDenied, _impl_.permission_), 2>(),
     {8, 2, 0,
      PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.permission_)}},
    // optional uint32 channel_id = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionDenied, _impl_.channel_id_), 3>(),
     {16, 3, 0,
      PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.channel_id_)}},
    // optional uint32 session = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionDenied, _impl_.session_), 4>(),
     {24, 4, 0,
      PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.session_)}},
    // optional string reason = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 0, 0,
      PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.reason_)}},
    // optional .MumbleProto.PermissionDenied.DenyType type = 5;
    {::_pbi::TcParser::FastEr0S1,
     {40, 5, 11,
      PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.type_)}},
    // optional string name = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 1, 0,
      PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.name_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 permission = 1;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.permission_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 channel_id = 2;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.channel_id_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 session = 3;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.session_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string reason = 4;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.reason_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional .MumbleProto.PermissionDenied.DenyType type = 5;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.type_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional string name = 6;
    {PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.name_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  {{
      {0, 11},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void PermissionDenied::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.PermissionDenied)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.reason_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000003cU)) {
    ::memset(&_impl_.permission_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.permission_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PermissionDenied::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PermissionDenied& this_ = static_cast<const PermissionDenied&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PermissionDenied::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PermissionDenied& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.PermissionDenied)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 permission = 1;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_permission(), target);
  }

  // optional uint32 channel_id = 2;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_channel_id(), target);
  }

  // optional uint32 session = 3;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_session(), target);
  }

  // optional string reason = 4;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_reason();
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional .MumbleProto.PermissionDenied.DenyType type = 5;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this_._internal_type(), target);
  }

  // optional string name = 6;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_name();
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.PermissionDenied)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PermissionDenied::ByteSizeLong(const MessageLite& base) {
  const PermissionDenied& this_ = static_cast<const PermissionDenied&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PermissionDenied::ByteSizeLong() const {
  const PermissionDenied& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.PermissionDenied)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    // optional string reason = 4;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_reason());
    }
    // optional string name = 6;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional uint32 permission = 1;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_permission());
    }
    // optional uint32 channel_id = 2;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
    // optional uint32 session = 3;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional .MumbleProto.PermissionDenied.DenyType type = 5;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PermissionDenied::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PermissionDenied*>(&to_msg);
  auto& from = static_cast<const PermissionDenied&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.PermissionDenied)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_reason(from._internal_reason());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_name(from._internal_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.permission_ = from._impl_.permission_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.type_ = from._impl_.type_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PermissionDenied::CopyFrom(const PermissionDenied& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.PermissionDenied)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PermissionDenied::InternalSwap(PermissionDenied* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reason_, &other->_impl_.reason_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.type_)
      + sizeof(PermissionDenied::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(PermissionDenied, _impl_.permission_)>(
          reinterpret_cast<char*>(&_impl_.permission_),
          reinterpret_cast<char*>(&other->_impl_.permission_));
}

::google::protobuf::Metadata PermissionDenied::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ACL_ChanGroup::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ACL_ChanGroup>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

ACL_ChanGroup::ACL_ChanGroup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_ChanGroup_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ACL.ChanGroup)
}
PROTOBUF_NDEBUG_INLINE ACL_ChanGroup::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::ACL_ChanGroup& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        add_{visibility, arena, from.add_},
        remove_{visibility, arena, from.remove_},
        inherited_members_{visibility, arena, from.inherited_members_},
        name_(arena, from.name_) {}

ACL_ChanGroup::ACL_ChanGroup(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ACL_ChanGroup& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_ChanGroup_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ACL_ChanGroup* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, inherited_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, inherited_),
           offsetof(Impl_, inheritable_) -
               offsetof(Impl_, inherited_) +
               sizeof(Impl_::inheritable_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.ACL.ChanGroup)
}
PROTOBUF_NDEBUG_INLINE ACL_ChanGroup::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        add_{visibility, arena},
        remove_{visibility, arena},
        inherited_members_{visibility, arena},
        name_(arena),
        inherited_{true},
        inherit_{true},
        inheritable_{true} {}

inline void ACL_ChanGroup::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ACL_ChanGroup::~ACL_ChanGroup() {
  // @@protoc_insertion_point(destructor:MumbleProto.ACL.ChanGroup)
  SharedDtor(*this);
}
inline void ACL_ChanGroup::SharedDtor(MessageLite& self) {
  ACL_ChanGroup& this_ = static_cast<ACL_ChanGroup&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ACL_ChanGroup::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ACL_ChanGroup(arena);
}
constexpr auto ACL_ChanGroup::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.add_) +
          decltype(ACL_ChanGroup::_impl_.add_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.remove_) +
          decltype(ACL_ChanGroup::_impl_.remove_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_members_) +
          decltype(ACL_ChanGroup::_impl_.inherited_members_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ACL_ChanGroup), alignof(ACL_ChanGroup), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ACL_ChanGroup::PlacementNew_,
                                 sizeof(ACL_ChanGroup),
                                 alignof(ACL_ChanGroup));
  }
}
constexpr auto ACL_ChanGroup::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ACL_ChanGroup_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ACL_ChanGroup::IsInitializedImpl,
          &ACL_ChanGroup::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ACL_ChanGroup>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ACL_ChanGroup::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ACL_ChanGroup>(), &ACL_ChanGroup::ByteSizeLong,
              &ACL_ChanGroup::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_._cached_size_),
          false,
      },
      &ACL_ChanGroup::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ACL_ChanGroup_class_data_ =
        ACL_ChanGroup::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ACL_ChanGroup::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ACL_ChanGroup_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ACL_ChanGroup_class_data_.tc_table);
  return ACL_ChanGroup_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 2>
ACL_ChanGroup::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ACL_ChanGroup_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ACL_ChanGroup>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required string name = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 3, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.name_)}},
    // optional bool inherited = 2 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanGroup, _impl_.inherited_), 4>(),
     {16, 4, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_)}},
    // optional bool inherit = 3 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanGroup, _impl_.inherit_), 5>(),
     {24, 5, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherit_)}},
    // optional bool inheritable = 4 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanGroup, _impl_.inheritable_), 6>(),
     {32, 6, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inheritable_)}},
    // repeated uint32 add = 5;
    {::_pbi::TcParser::FastV32R1,
     {40, 0, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.add_)}},
    // repeated uint32 remove = 6;
    {::_pbi::TcParser::FastV32R1,
     {48, 1, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.remove_)}},
    // repeated uint32 inherited_members = 7;
    {::_pbi::TcParser::FastV32R1,
     {56, 2, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_members_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string name = 1;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.name_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool inherited = 2 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool inherit = 3 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherit_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool inheritable = 4 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inheritable_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated uint32 add = 5;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.add_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 remove = 6;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.remove_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 inherited_members = 7;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_members_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ACL_ChanGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ACL.ChanGroup)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.add_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.remove_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.inherited_members_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    _impl_.inherited_ = true;
    _impl_.inherit_ = true;
    _impl_.inheritable_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ACL_ChanGroup::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ACL_ChanGroup& this_ = static_cast<const ACL_ChanGroup&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ACL_ChanGroup::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ACL_ChanGroup& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ACL.ChanGroup)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required string name = 1;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    const ::std::string& _s = this_._internal_name();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional bool inherited = 2 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_inherited(), target);
  }

  // optional bool inherit = 3 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_inherit(), target);
  }

  // optional bool inheritable = 4 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_inheritable(), target);
  }

  // repeated uint32 add = 5;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_add_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          5, this_._internal_add().Get(i), target);
    }
  }

  // repeated uint32 remove = 6;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (int i = 0, n = this_._internal_remove_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          6, this_._internal_remove().Get(i), target);
    }
  }

  // repeated uint32 inherited_members = 7;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (int i = 0, n = this_._internal_inherited_members_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          7, this_._internal_inherited_members().Get(i), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ACL.ChanGroup)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ACL_ChanGroup::ByteSizeLong(const MessageLite& base) {
  const ACL_ChanGroup& this_ = static_cast<const ACL_ChanGroup&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ACL_ChanGroup::ByteSizeLong() const {
  const ACL_ChanGroup& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ACL.ChanGroup)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000070U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated uint32 add = 5;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_add());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_add_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 remove = 6;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_remove());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_remove_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 inherited_members = 7;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_inherited_members());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_inherited_members_size());
      total_size += tag_size + data_size;
    }
  }
   {
    // required string name = 1;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ACL_ChanGroup::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ACL_ChanGroup*>(&to_msg);
  auto& from = static_cast<const ACL_ChanGroup&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ACL.ChanGroup)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_add()->MergeFrom(from._internal_add());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_remove()->MergeFrom(from._internal_remove());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_inherited_members()->MergeFrom(from._internal_inherited_members());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_internal_set_name(from._internal_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.inherited_ = from._impl_.inherited_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.inherit_ = from._impl_.inherit_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.inheritable_ = from._impl_.inheritable_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ACL_ChanGroup::CopyFrom(const ACL_ChanGroup& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ACL.ChanGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ACL_ChanGroup::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ACL_ChanGroup&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ACL_ChanGroup::InternalSwap(ACL_ChanGroup* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.add_.InternalSwap(&other->_impl_.add_);
  _impl_.remove_.InternalSwap(&other->_impl_.remove_);
  _impl_.inherited_members_.InternalSwap(&other->_impl_.inherited_members_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inheritable_)
      + sizeof(ACL_ChanGroup::_impl_.inheritable_)
      - PROTOBUF_FIELD_OFFSET(ACL_ChanGroup, _impl_.inherited_)>(
          reinterpret_cast<char*>(&_impl_.inherited_),
          reinterpret_cast<char*>(&other->_impl_.inherited_));
}

::google::protobuf::Metadata ACL_ChanGroup::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ACL_ChanACL::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ACL_ChanACL>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_._has_bits_);
};

ACL_ChanACL::ACL_ChanACL(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_ChanACL_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ACL.ChanACL)
}
PROTOBUF_NDEBUG_INLINE ACL_ChanACL::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::ACL_ChanACL& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        group_(arena, from.group_) {}

ACL_ChanACL::ACL_ChanACL(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ACL_ChanACL& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_ChanACL_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ACL_ChanACL* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, user_id_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, user_id_),
           offsetof(Impl_, inherited_) -
               offsetof(Impl_, user_id_) +
               sizeof(Impl_::inherited_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.ACL.ChanACL)
}
PROTOBUF_NDEBUG_INLINE ACL_ChanACL::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        group_(arena),
        apply_here_{true},
        apply_subs_{true},
        inherited_{true} {}

inline void ACL_ChanACL::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, user_id_),
           0,
           offsetof(Impl_, deny_) -
               offsetof(Impl_, user_id_) +
               sizeof(Impl_::deny_));
}
ACL_ChanACL::~ACL_ChanACL() {
  // @@protoc_insertion_point(destructor:MumbleProto.ACL.ChanACL)
  SharedDtor(*this);
}
inline void ACL_ChanACL::SharedDtor(MessageLite& self) {
  ACL_ChanACL& this_ = static_cast<ACL_ChanACL&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.group_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ACL_ChanACL::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ACL_ChanACL(arena);
}
constexpr auto ACL_ChanACL::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ACL_ChanACL),
                                            alignof(ACL_ChanACL));
}
constexpr auto ACL_ChanACL::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ACL_ChanACL_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ACL_ChanACL::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ACL_ChanACL>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ACL_ChanACL::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ACL_ChanACL>(), &ACL_ChanACL::ByteSizeLong,
              &ACL_ChanACL::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_._cached_size_),
          false,
      },
      &ACL_ChanACL::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ACL_ChanACL_class_data_ =
        ACL_ChanACL::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ACL_ChanACL::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ACL_ChanACL_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ACL_ChanACL_class_data_.tc_table);
  return ACL_ChanACL_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 2>
ACL_ChanACL::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ACL_ChanACL_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ACL_ChanACL>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool apply_here = 1 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanACL, _impl_.apply_here_), 4>(),
     {8, 4, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.apply_here_)}},
    // optional bool apply_subs = 2 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanACL, _impl_.apply_subs_), 5>(),
     {16, 5, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.apply_subs_)}},
    // optional bool inherited = 3 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL_ChanACL, _impl_.inherited_), 6>(),
     {24, 6, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.inherited_)}},
    // optional uint32 user_id = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ACL_ChanACL, _impl_.user_id_), 1>(),
     {32, 1, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.user_id_)}},
    // optional string group = 5;
    {::_pbi::TcParser::FastBS1,
     {42, 0, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.group_)}},
    // optional uint32 grant = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ACL_ChanACL, _impl_.grant_), 2>(),
     {48, 2, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.grant_)}},
    // optional uint32 deny = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ACL_ChanACL, _impl_.deny_), 3>(),
     {56, 3, 0,
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.deny_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool apply_here = 1 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.apply_here_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool apply_subs = 2 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.apply_subs_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool inherited = 3 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.inherited_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 user_id = 4;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.user_id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string group = 5;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.group_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 grant = 6;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.grant_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 deny = 7;
    {PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.deny_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ACL_ChanACL::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ACL.ChanACL)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.group_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000007eU)) {
    ::memset(&_impl_.user_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.deny_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.deny_));
    _impl_.apply_here_ = true;
    _impl_.apply_subs_ = true;
    _impl_.inherited_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ACL_ChanACL::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ACL_ChanACL& this_ = static_cast<const ACL_ChanACL&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ACL_ChanACL::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ACL_ChanACL& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ACL.ChanACL)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool apply_here = 1 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this_._internal_apply_here(), target);
  }

  // optional bool apply_subs = 2 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_apply_subs(), target);
  }

  // optional bool inherited = 3 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_inherited(), target);
  }

  // optional uint32 user_id = 4;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_user_id(), target);
  }

  // optional string group = 5;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_group();
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional uint32 grant = 6;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_grant(), target);
  }

  // optional uint32 deny = 7;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_deny(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ACL.ChanACL)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ACL_ChanACL::ByteSizeLong(const MessageLite& base) {
  const ACL_ChanACL& this_ = static_cast<const ACL_ChanACL&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ACL_ChanACL::ByteSizeLong() const {
  const ACL_ChanACL& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ACL.ChanACL)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000070U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional string group = 5;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_group());
    }
    // optional uint32 user_id = 4;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_user_id());
    }
    // optional uint32 grant = 6;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_grant());
    }
    // optional uint32 deny = 7;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_deny());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ACL_ChanACL::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ACL_ChanACL*>(&to_msg);
  auto& from = static_cast<const ACL_ChanACL&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ACL.ChanACL)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000007fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_group(from._internal_group());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.grant_ = from._impl_.grant_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.deny_ = from._impl_.deny_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.apply_here_ = from._impl_.apply_here_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.apply_subs_ = from._impl_.apply_subs_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.inherited_ = from._impl_.inherited_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ACL_ChanACL::CopyFrom(const ACL_ChanACL& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ACL.ChanACL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ACL_ChanACL::InternalSwap(ACL_ChanACL* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.group_, &other->_impl_.group_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.inherited_)
      + sizeof(ACL_ChanACL::_impl_.inherited_)
      - PROTOBUF_FIELD_OFFSET(ACL_ChanACL, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

::google::protobuf::Metadata ACL_ChanACL::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ACL::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ACL>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ACL, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

ACL::ACL(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ACL)
}
PROTOBUF_NDEBUG_INLINE ACL::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::ACL& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        groups_{visibility, arena, from.groups_},
        acls_{visibility, arena, from.acls_} {}

ACL::ACL(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ACL& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ACL_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ACL* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, channel_id_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, channel_id_),
           offsetof(Impl_, inherit_acls_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::inherit_acls_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.ACL)
}
PROTOBUF_NDEBUG_INLINE ACL::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        groups_{visibility, arena},
        acls_{visibility, arena},
        inherit_acls_{true} {}

inline void ACL::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, channel_id_),
           0,
           offsetof(Impl_, query_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::query_));
}
ACL::~ACL() {
  // @@protoc_insertion_point(destructor:MumbleProto.ACL)
  SharedDtor(*this);
}
inline void ACL::SharedDtor(MessageLite& self) {
  ACL& this_ = static_cast<ACL&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ACL::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ACL(arena);
}
constexpr auto ACL::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.groups_) +
          decltype(ACL::_impl_.groups_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.acls_) +
          decltype(ACL::_impl_.acls_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(ACL), alignof(ACL), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&ACL::PlacementNew_,
                                 sizeof(ACL),
                                 alignof(ACL));
  }
}
constexpr auto ACL::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ACL_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ACL::IsInitializedImpl,
          &ACL::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ACL>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ACL::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ACL>(), &ACL::ByteSizeLong,
              &ACL::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ACL, _impl_._cached_size_),
          false,
      },
      &ACL::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ACL_class_data_ =
        ACL::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ACL::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ACL_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ACL_class_data_.tc_table);
  return ACL_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 0, 2>
ACL::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ACL, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ACL_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ACL>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // required uint32 channel_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ACL, _impl_.channel_id_), 2>(),
     {8, 2, 0,
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.channel_id_)}},
    // optional bool inherit_acls = 2 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL, _impl_.inherit_acls_), 4>(),
     {16, 4, 0,
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.inherit_acls_)}},
    // repeated .MumbleProto.ACL.ChanGroup groups = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.groups_)}},
    // repeated .MumbleProto.ACL.ChanACL acls = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 1, 1,
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.acls_)}},
    // optional bool query = 5 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ACL, _impl_.query_), 3>(),
     {40, 3, 0,
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.query_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint32 channel_id = 1;
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.channel_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool inherit_acls = 2 [default = true];
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.inherit_acls_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .MumbleProto.ACL.ChanGroup groups = 3;
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.groups_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .MumbleProto.ACL.ChanACL acls = 4;
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.acls_), _Internal::kHasBitsOffset + 1, 1, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bool query = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(ACL, _impl_.query_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::MumbleProto::ACL_ChanGroup>()},
      {::_pbi::TcParser::GetTable<::MumbleProto::ACL_ChanACL>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ACL::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ACL)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.groups_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.acls_.Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000001cU)) {
    ::memset(&_impl_.channel_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.query_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.query_));
    _impl_.inherit_acls_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ACL::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ACL& this_ = static_cast<const ACL&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ACL::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ACL& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ACL)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required uint32 channel_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_channel_id(), target);
  }

  // optional bool inherit_acls = 2 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_inherit_acls(), target);
  }

  // repeated .MumbleProto.ACL.ChanGroup groups = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_groups_size());
         i < n; i++) {
      const auto& repfield = this_._internal_groups().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              3, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // repeated .MumbleProto.ACL.ChanACL acls = 4;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_acls_size());
         i < n; i++) {
      const auto& repfield = this_._internal_acls().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              4, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  // optional bool query = 5 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_query(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ACL)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ACL::ByteSizeLong(const MessageLite& base) {
  const ACL& this_ = static_cast<const ACL&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ACL::ByteSizeLong() const {
  const ACL& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ACL)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000018U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated .MumbleProto.ACL.ChanGroup groups = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_groups_size();
      for (const auto& msg : this_._internal_groups()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // repeated .MumbleProto.ACL.ChanACL acls = 4;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size += 1UL * this_._internal_acls_size();
      for (const auto& msg : this_._internal_acls()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
   {
    // required uint32 channel_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ACL::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ACL*>(&to_msg);
  auto& from = static_cast<const ACL&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ACL)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_groups()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_groups());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_acls()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_acls());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.query_ = from._impl_.query_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.inherit_acls_ = from._impl_.inherit_acls_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ACL::CopyFrom(const ACL& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ACL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ACL::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ACL&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this_._internal_groups()))
    return false;
  return true;
}

void ACL::InternalSwap(ACL* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.groups_.InternalSwap(&other->_impl_.groups_);
  _impl_.acls_.InternalSwap(&other->_impl_.acls_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACL, _impl_.inherit_acls_)
      + sizeof(ACL::_impl_.inherit_acls_)
      - PROTOBUF_FIELD_OFFSET(ACL, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::google::protobuf::Metadata ACL::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class QueryUsers::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<QueryUsers>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_._has_bits_);
};

QueryUsers::QueryUsers(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, QueryUsers_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.QueryUsers)
}
PROTOBUF_NDEBUG_INLINE QueryUsers::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::QueryUsers& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        ids_{visibility, arena, from.ids_},
        names_{visibility, arena, from.names_} {}

QueryUsers::QueryUsers(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const QueryUsers& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, QueryUsers_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  QueryUsers* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:MumbleProto.QueryUsers)
}
PROTOBUF_NDEBUG_INLINE QueryUsers::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        ids_{visibility, arena},
        names_{visibility, arena} {}

inline void QueryUsers::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
QueryUsers::~QueryUsers() {
  // @@protoc_insertion_point(destructor:MumbleProto.QueryUsers)
  SharedDtor(*this);
}
inline void QueryUsers::SharedDtor(MessageLite& self) {
  QueryUsers& this_ = static_cast<QueryUsers&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL QueryUsers::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) QueryUsers(arena);
}
constexpr auto QueryUsers::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.ids_) +
          decltype(QueryUsers::_impl_.ids_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.names_) +
          decltype(QueryUsers::_impl_.names_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(QueryUsers), alignof(QueryUsers), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&QueryUsers::PlacementNew_,
                                 sizeof(QueryUsers),
                                 alignof(QueryUsers));
  }
}
constexpr auto QueryUsers::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_QueryUsers_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &QueryUsers::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<QueryUsers>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &QueryUsers::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<QueryUsers>(), &QueryUsers::ByteSizeLong,
              &QueryUsers::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_._cached_size_),
          false,
      },
      &QueryUsers::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull QueryUsers_class_data_ =
        QueryUsers::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
QueryUsers::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&QueryUsers_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(QueryUsers_class_data_.tc_table);
  return QueryUsers_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
QueryUsers::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    QueryUsers_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::QueryUsers>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated string names = 2;
    {::_pbi::TcParser::FastBR1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.names_)}},
    // repeated uint32 ids = 1;
    {::_pbi::TcParser::FastV32R1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.ids_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 ids = 1;
    {PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.ids_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated string names = 2;
    {PROTOBUF_FIELD_OFFSET(QueryUsers, _impl_.names_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void QueryUsers::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.QueryUsers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.ids_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.names_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL QueryUsers::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const QueryUsers& this_ = static_cast<const QueryUsers&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL QueryUsers::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const QueryUsers& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.QueryUsers)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated uint32 ids = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_ids_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_ids().Get(i), target);
    }
  }

  // repeated string names = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (int i = 0, n = this_._internal_names_size(); i < n; ++i) {
      const auto& s = this_._internal_names().Get(i);
      target = stream->WriteString(2, s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.QueryUsers)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t QueryUsers::ByteSizeLong(const MessageLite& base) {
  const QueryUsers& this_ = static_cast<const QueryUsers&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t QueryUsers::ByteSizeLong() const {
  const QueryUsers& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.QueryUsers)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated uint32 ids = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_ids());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_ids_size());
      total_size += tag_size + data_size;
    }
    // repeated string names = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_names().size());
      for (int i = 0, n = this_._internal_names().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_names().Get(i));
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void QueryUsers::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<QueryUsers*>(&to_msg);
  auto& from = static_cast<const QueryUsers&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.QueryUsers)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_ids()->MergeFrom(from._internal_ids());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_names()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_names());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void QueryUsers::CopyFrom(const QueryUsers& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.QueryUsers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void QueryUsers::InternalSwap(QueryUsers* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ids_.InternalSwap(&other->_impl_.ids_);
  _impl_.names_.InternalSwap(&other->_impl_.names_);
}

::google::protobuf::Metadata QueryUsers::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CryptSetup::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CryptSetup>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_._has_bits_);
};

CryptSetup::CryptSetup(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CryptSetup_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.CryptSetup)
}
PROTOBUF_NDEBUG_INLINE CryptSetup::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::CryptSetup& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        key_(arena, from.key_),
        client_nonce_(arena, from.client_nonce_),
        server_nonce_(arena, from.server_nonce_) {}

CryptSetup::CryptSetup(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const CryptSetup& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CryptSetup_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CryptSetup* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:MumbleProto.CryptSetup)
}
PROTOBUF_NDEBUG_INLINE CryptSetup::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        key_(arena),
        client_nonce_(arena),
        server_nonce_(arena) {}

inline void CryptSetup::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CryptSetup::~CryptSetup() {
  // @@protoc_insertion_point(destructor:MumbleProto.CryptSetup)
  SharedDtor(*this);
}
inline void CryptSetup::SharedDtor(MessageLite& self) {
  CryptSetup& this_ = static_cast<CryptSetup&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.key_.Destroy();
  this_._impl_.client_nonce_.Destroy();
  this_._impl_.server_nonce_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CryptSetup::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CryptSetup(arena);
}
constexpr auto CryptSetup::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(CryptSetup),
                                            alignof(CryptSetup));
}
constexpr auto CryptSetup::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CryptSetup_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &CryptSetup::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CryptSetup>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CryptSetup::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CryptSetup>(), &CryptSetup::ByteSizeLong,
              &CryptSetup::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_._cached_size_),
          false,
      },
      &CryptSetup::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CryptSetup_class_data_ =
        CryptSetup::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CryptSetup::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CryptSetup_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CryptSetup_class_data_.tc_table);
  return CryptSetup_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
CryptSetup::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CryptSetup_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::CryptSetup>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes key = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.key_)}},
    // optional bytes client_nonce = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.client_nonce_)}},
    // optional bytes server_nonce = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 2, 0,
      PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.server_nonce_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes key = 1;
    {PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.key_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes client_nonce = 2;
    {PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.client_nonce_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes server_nonce = 3;
    {PROTOBUF_FIELD_OFFSET(CryptSetup, _impl_.server_nonce_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void CryptSetup::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.CryptSetup)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.client_nonce_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.server_nonce_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CryptSetup::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CryptSetup& this_ = static_cast<const CryptSetup&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CryptSetup::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CryptSetup& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.CryptSetup)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bytes key = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_key();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional bytes client_nonce = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_client_nonce();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional bytes server_nonce = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_server_nonce();
    target = stream->WriteBytesMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.CryptSetup)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CryptSetup::ByteSizeLong(const MessageLite& base) {
  const CryptSetup& this_ = static_cast<const CryptSetup&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CryptSetup::ByteSizeLong() const {
  const CryptSetup& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.CryptSetup)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // optional bytes key = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_key());
    }
    // optional bytes client_nonce = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_client_nonce());
    }
    // optional bytes server_nonce = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_server_nonce());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CryptSetup::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CryptSetup*>(&to_msg);
  auto& from = static_cast<const CryptSetup&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.CryptSetup)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_key(from._internal_key());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_client_nonce(from._internal_client_nonce());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_server_nonce(from._internal_server_nonce());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CryptSetup::CopyFrom(const CryptSetup& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.CryptSetup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CryptSetup::InternalSwap(CryptSetup* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.key_, &other->_impl_.key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_nonce_, &other->_impl_.client_nonce_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.server_nonce_, &other->_impl_.server_nonce_, arena);
}

::google::protobuf::Metadata CryptSetup::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ContextActionModify::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ContextActionModify>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ContextActionModify::ContextActionModify(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ContextActionModify_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ContextActionModify)
}
PROTOBUF_NDEBUG_INLINE ContextActionModify::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::ContextActionModify& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        action_(arena, from.action_),
        text_(arena, from.text_) {}

ContextActionModify::ContextActionModify(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ContextActionModify& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ContextActionModify_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ContextActionModify* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, context_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, context_),
           offsetof(Impl_, operation_) -
               offsetof(Impl_, context_) +
               sizeof(Impl_::operation_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.ContextActionModify)
}
PROTOBUF_NDEBUG_INLINE ContextActionModify::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        action_(arena),
        text_(arena) {}

inline void ContextActionModify::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, context_),
           0,
           offsetof(Impl_, operation_) -
               offsetof(Impl_, context_) +
               sizeof(Impl_::operation_));
}
ContextActionModify::~ContextActionModify() {
  // @@protoc_insertion_point(destructor:MumbleProto.ContextActionModify)
  SharedDtor(*this);
}
inline void ContextActionModify::SharedDtor(MessageLite& self) {
  ContextActionModify& this_ = static_cast<ContextActionModify&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.action_.Destroy();
  this_._impl_.text_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ContextActionModify::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ContextActionModify(arena);
}
constexpr auto ContextActionModify::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ContextActionModify),
                                            alignof(ContextActionModify));
}
constexpr auto ContextActionModify::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ContextActionModify_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ContextActionModify::IsInitializedImpl,
          &ContextActionModify::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ContextActionModify>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ContextActionModify::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ContextActionModify>(), &ContextActionModify::ByteSizeLong,
              &ContextActionModify::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_._cached_size_),
          false,
      },
      &ContextActionModify::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ContextActionModify_class_data_ =
        ContextActionModify::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ContextActionModify::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ContextActionModify_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ContextActionModify_class_data_.tc_table);
  return ContextActionModify_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2>
ContextActionModify::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ContextActionModify_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ContextActionModify>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional .MumbleProto.ContextActionModify.Operation operation = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 3, 1,
      PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.operation_)}},
    // required string action = 1;
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.action_)}},
    // optional string text = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 1, 0,
      PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.text_)}},
    // optional uint32 context = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ContextActionModify, _impl_.context_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.context_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required string action = 1;
    {PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.action_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string text = 2;
    {PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.text_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 context = 3;
    {PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.context_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .MumbleProto.ContextActionModify.Operation operation = 4;
    {PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.operation_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }},
  {{
      {0, 1},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ContextActionModify::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ContextActionModify)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.action_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.text_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000cU)) {
    ::memset(&_impl_.context_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.operation_) -
        reinterpret_cast<char*>(&_impl_.context_)) + sizeof(_impl_.operation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ContextActionModify::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ContextActionModify& this_ = static_cast<const ContextActionModify&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ContextActionModify::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ContextActionModify& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ContextActionModify)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required string action = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_action();
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string text = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_text();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional uint32 context = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_context(), target);
  }

  // optional .MumbleProto.ContextActionModify.Operation operation = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this_._internal_operation(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ContextActionModify)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ContextActionModify::ByteSizeLong(const MessageLite& base) {
  const ContextActionModify& this_ = static_cast<const ContextActionModify&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ContextActionModify::ByteSizeLong() const {
  const ContextActionModify& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ContextActionModify)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // required string action = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_action());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000eU)) {
    // optional string text = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_text());
    }
    // optional uint32 context = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_context());
    }
    // optional .MumbleProto.ContextActionModify.Operation operation = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_operation());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ContextActionModify::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ContextActionModify*>(&to_msg);
  auto& from = static_cast<const ContextActionModify&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ContextActionModify)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_action(from._internal_action());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_text(from._internal_text());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.context_ = from._impl_.context_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.operation_ = from._impl_.operation_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ContextActionModify::CopyFrom(const ContextActionModify& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ContextActionModify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ContextActionModify::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ContextActionModify&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ContextActionModify::InternalSwap(ContextActionModify* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_, &other->_impl_.action_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.text_, &other->_impl_.text_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.operation_)
      + sizeof(ContextActionModify::_impl_.operation_)
      - PROTOBUF_FIELD_OFFSET(ContextActionModify, _impl_.context_)>(
          reinterpret_cast<char*>(&_impl_.context_),
          reinterpret_cast<char*>(&other->_impl_.context_));
}

::google::protobuf::Metadata ContextActionModify::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ContextAction::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ContextAction>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ContextAction, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

ContextAction::ContextAction(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ContextAction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ContextAction)
}
PROTOBUF_NDEBUG_INLINE ContextAction::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::ContextAction& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        action_(arena, from.action_) {}

ContextAction::ContextAction(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ContextAction& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ContextAction_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ContextAction* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, channel_id_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::channel_id_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.ContextAction)
}
PROTOBUF_NDEBUG_INLINE ContextAction::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        action_(arena) {}

inline void ContextAction::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           0,
           offsetof(Impl_, channel_id_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::channel_id_));
}
ContextAction::~ContextAction() {
  // @@protoc_insertion_point(destructor:MumbleProto.ContextAction)
  SharedDtor(*this);
}
inline void ContextAction::SharedDtor(MessageLite& self) {
  ContextAction& this_ = static_cast<ContextAction&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.action_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ContextAction::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ContextAction(arena);
}
constexpr auto ContextAction::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ContextAction),
                                            alignof(ContextAction));
}
constexpr auto ContextAction::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ContextAction_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          ContextAction::IsInitializedImpl,
          &ContextAction::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ContextAction>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ContextAction::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ContextAction>(), &ContextAction::ByteSizeLong,
              &ContextAction::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ContextAction, _impl_._cached_size_),
          false,
      },
      &ContextAction::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ContextAction_class_data_ =
        ContextAction::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ContextAction::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ContextAction_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ContextAction_class_data_.tc_table);
  return ContextAction_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
ContextAction::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ContextAction, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ContextAction_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ContextAction>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ContextAction, _impl_.session_), 1>(),
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.session_)}},
    // optional uint32 channel_id = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ContextAction, _impl_.channel_id_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.channel_id_)}},
    // required string action = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.action_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.session_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 channel_id = 2;
    {PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.channel_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // required string action = 3;
    {PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.action_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ContextAction::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ContextAction)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.action_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000006U)) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.channel_id_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.channel_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ContextAction::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ContextAction& this_ = static_cast<const ContextAction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ContextAction::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ContextAction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ContextAction)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 session = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional uint32 channel_id = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_channel_id(), target);
  }

  // required string action = 3;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_action();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ContextAction)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ContextAction::ByteSizeLong(const MessageLite& base) {
  const ContextAction& this_ = static_cast<const ContextAction&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ContextAction::ByteSizeLong() const {
  const ContextAction& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ContextAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // required string action = 3;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_action());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00000006U)) {
    // optional uint32 session = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional uint32 channel_id = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ContextAction::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ContextAction*>(&to_msg);
  auto& from = static_cast<const ContextAction&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ContextAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_action(from._internal_action());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ContextAction::CopyFrom(const ContextAction& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ContextAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ContextAction::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const ContextAction&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void ContextAction::InternalSwap(ContextAction* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_, &other->_impl_.action_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.channel_id_)
      + sizeof(ContextAction::_impl_.channel_id_)
      - PROTOBUF_FIELD_OFFSET(ContextAction, _impl_.session_)>(
          reinterpret_cast<char*>(&_impl_.session_),
          reinterpret_cast<char*>(&other->_impl_.session_));
}

::google::protobuf::Metadata ContextAction::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserList_User::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserList_User>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserList_User, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

UserList_User::UserList_User(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserList_User_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.UserList.User)
}
PROTOBUF_NDEBUG_INLINE UserList_User::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::UserList_User& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        name_(arena, from.name_),
        last_seen_(arena, from.last_seen_) {}

UserList_User::UserList_User(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserList_User& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserList_User_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserList_User* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, user_id_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, user_id_),
           offsetof(Impl_, last_channel_) -
               offsetof(Impl_, user_id_) +
               sizeof(Impl_::last_channel_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.UserList.User)
}
PROTOBUF_NDEBUG_INLINE UserList_User::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        name_(arena),
        last_seen_(arena) {}

inline void UserList_User::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, user_id_),
           0,
           offsetof(Impl_, last_channel_) -
               offsetof(Impl_, user_id_) +
               sizeof(Impl_::last_channel_));
}
UserList_User::~UserList_User() {
  // @@protoc_insertion_point(destructor:MumbleProto.UserList.User)
  SharedDtor(*this);
}
inline void UserList_User::SharedDtor(MessageLite& self) {
  UserList_User& this_ = static_cast<UserList_User&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.last_seen_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserList_User::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserList_User(arena);
}
constexpr auto UserList_User::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(UserList_User),
                                            alignof(UserList_User));
}
constexpr auto UserList_User::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserList_User_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          UserList_User::IsInitializedImpl,
          &UserList_User::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserList_User>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserList_User::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserList_User>(), &UserList_User::ByteSizeLong,
              &UserList_User::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserList_User, _impl_._cached_size_),
          false,
      },
      &UserList_User::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserList_User_class_data_ =
        UserList_User::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserList_User::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserList_User_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserList_User_class_data_.tc_table);
  return UserList_User_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
UserList_User::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserList_User, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UserList_User_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::UserList_User>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint32 last_channel = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserList_User, _impl_.last_channel_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_channel_)}},
    // required uint32 user_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserList_User, _impl_.user_id_), 2>(),
     {8, 2, 0,
      PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.user_id_)}},
    // optional string name = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.name_)}},
    // optional string last_seen = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_seen_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required uint32 user_id = 1;
    {PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.user_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string name = 2;
    {PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.name_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional string last_seen = 3;
    {PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_seen_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 last_channel = 4;
    {PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_channel_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UserList_User::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.UserList.User)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.last_seen_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000000cU)) {
    ::memset(&_impl_.user_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.last_channel_) -
        reinterpret_cast<char*>(&_impl_.user_id_)) + sizeof(_impl_.last_channel_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserList_User::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserList_User& this_ = static_cast<const UserList_User&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserList_User::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserList_User& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.UserList.User)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required uint32 user_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_user_id(), target);
  }

  // optional string name = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_name();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string last_seen = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_last_seen();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint32 last_channel = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_last_channel(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.UserList.User)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserList_User::ByteSizeLong(const MessageLite& base) {
  const UserList_User& this_ = static_cast<const UserList_User&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserList_User::ByteSizeLong() const {
  const UserList_User& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.UserList.User)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional string name = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_name());
    }
    // optional string last_seen = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_last_seen());
    }
  }
   {
    // required uint32 user_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_user_id());
    }
  }
   {
    // optional uint32 last_channel = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_last_channel());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserList_User::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<UserList_User*>(&to_msg);
  auto& from = static_cast<const UserList_User&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.UserList.User)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_name(from._internal_name());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_last_seen(from._internal_last_seen());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.user_id_ = from._impl_.user_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.last_channel_ = from._impl_.last_channel_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void UserList_User::CopyFrom(const UserList_User& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.UserList.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UserList_User::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UserList_User&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void UserList_User::InternalSwap(UserList_User* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.last_seen_, &other->_impl_.last_seen_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.last_channel_)
      + sizeof(UserList_User::_impl_.last_channel_)
      - PROTOBUF_FIELD_OFFSET(UserList_User, _impl_.user_id_)>(
          reinterpret_cast<char*>(&_impl_.user_id_),
          reinterpret_cast<char*>(&other->_impl_.user_id_));
}

::google::protobuf::Metadata UserList_User::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserList::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserList>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserList, _impl_._has_bits_);
};

UserList::UserList(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserList_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.UserList)
}
PROTOBUF_NDEBUG_INLINE UserList::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::UserList& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        users_{visibility, arena, from.users_} {}

UserList::UserList(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserList& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserList_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserList* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:MumbleProto.UserList)
}
PROTOBUF_NDEBUG_INLINE UserList::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        users_{visibility, arena} {}

inline void UserList::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
UserList::~UserList() {
  // @@protoc_insertion_point(destructor:MumbleProto.UserList)
  SharedDtor(*this);
}
inline void UserList::SharedDtor(MessageLite& self) {
  UserList& this_ = static_cast<UserList&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserList::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserList(arena);
}
constexpr auto UserList::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(UserList, _impl_.users_) +
          decltype(UserList::_impl_.users_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(UserList), alignof(UserList), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&UserList::PlacementNew_,
                                 sizeof(UserList),
                                 alignof(UserList));
  }
}
constexpr auto UserList::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserList_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          UserList::IsInitializedImpl,
          &UserList::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserList>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserList::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserList>(), &UserList::ByteSizeLong,
              &UserList::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserList, _impl_._cached_size_),
          false,
      },
      &UserList::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserList_class_data_ =
        UserList::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserList::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserList_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserList_class_data_.tc_table);
  return UserList_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2>
UserList::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserList, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    UserList_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::UserList>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .MumbleProto.UserList.User users = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 0, 0,
      PROTOBUF_FIELD_OFFSET(UserList, _impl_.users_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .MumbleProto.UserList.User users = 1;
    {PROTOBUF_FIELD_OFFSET(UserList, _impl_.users_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::MumbleProto::UserList_User>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void UserList::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.UserList)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.users_.Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserList::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserList& this_ = static_cast<const UserList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserList::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.UserList)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated .MumbleProto.UserList.User users = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_users_size());
         i < n; i++) {
      const auto& repfield = this_._internal_users().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              1, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.UserList)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserList::ByteSizeLong(const MessageLite& base) {
  const UserList& this_ = static_cast<const UserList&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserList::ByteSizeLong() const {
  const UserList& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.UserList)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .MumbleProto.UserList.User users = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_users_size();
      for (const auto& msg : this_._internal_users()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserList::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<UserList*>(&to_msg);
  auto& from = static_cast<const UserList&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.UserList)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _this->_internal_mutable_users()->InternalMergeFromWithArena(
        ::google::protobuf::MessageLite::internal_visibility(), arena,
        from._internal_users());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void UserList::CopyFrom(const UserList& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.UserList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UserList::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const UserList&>(msg);
  if (!::google::protobuf::internal::AllAreInitialized(this_._internal_users()))
    return false;
  return true;
}

void UserList::InternalSwap(UserList* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.users_.InternalSwap(&other->_impl_.users_);
}

::google::protobuf::Metadata UserList::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class VoiceTarget_Target::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<VoiceTarget_Target>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_._has_bits_);
};

VoiceTarget_Target::VoiceTarget_Target(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, VoiceTarget_Target_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.VoiceTarget.Target)
}
PROTOBUF_NDEBUG_INLINE VoiceTarget_Target::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::VoiceTarget_Target& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        session_{visibility, arena, from.session_},
        group_(arena, from.group_) {}

VoiceTarget_Target::VoiceTarget_Target(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const VoiceTarget_Target& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, VoiceTarget_Target_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  VoiceTarget_Target* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, channel_id_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, channel_id_),
           offsetof(Impl_, children_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::children_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.VoiceTarget.Target)
}
PROTOBUF_NDEBUG_INLINE VoiceTarget_Target::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        session_{visibility, arena},
        group_(arena) {}

inline void VoiceTarget_Target::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, channel_id_),
           0,
           offsetof(Impl_, children_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::children_));
}
VoiceTarget_Target::~VoiceTarget_Target() {
  // @@protoc_insertion_point(destructor:MumbleProto.VoiceTarget.Target)
  SharedDtor(*this);
}
inline void VoiceTarget_Target::SharedDtor(MessageLite& self) {
  VoiceTarget_Target& this_ = static_cast<VoiceTarget_Target&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.group_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL VoiceTarget_Target::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) VoiceTarget_Target(arena);
}
constexpr auto VoiceTarget_Target::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.session_) +
          decltype(VoiceTarget_Target::_impl_.session_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(VoiceTarget_Target), alignof(VoiceTarget_Target), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&VoiceTarget_Target::PlacementNew_,
                                 sizeof(VoiceTarget_Target),
                                 alignof(VoiceTarget_Target));
  }
}
constexpr auto VoiceTarget_Target::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_VoiceTarget_Target_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &VoiceTarget_Target::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<VoiceTarget_Target>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &VoiceTarget_Target::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<VoiceTarget_Target>(), &VoiceTarget_Target::ByteSizeLong,
              &VoiceTarget_Target::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_._cached_size_),
          false,
      },
      &VoiceTarget_Target::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull VoiceTarget_Target_class_data_ =
        VoiceTarget_Target::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
VoiceTarget_Target::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&VoiceTarget_Target_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(VoiceTarget_Target_class_data_.tc_table);
  return VoiceTarget_Target_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2>
VoiceTarget_Target::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    VoiceTarget_Target_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::VoiceTarget_Target>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated uint32 session = 1;
    {::_pbi::TcParser::FastV32R1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.session_)}},
    // optional uint32 channel_id = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VoiceTarget_Target, _impl_.channel_id_), 2>(),
     {16, 2, 0,
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.channel_id_)}},
    // optional string group = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0,
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.group_)}},
    // optional bool links = 4 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(VoiceTarget_Target, _impl_.links_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.links_)}},
    // optional bool children = 5 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(VoiceTarget_Target, _impl_.children_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.children_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.session_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // optional uint32 channel_id = 2;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.channel_id_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string group = 3;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.group_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool links = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.links_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool children = 5 [default = false];
    {PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.children_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void VoiceTarget_Target::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.VoiceTarget.Target)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.session_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _impl_.group_.ClearNonDefaultToEmpty();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000001cU)) {
    ::memset(&_impl_.channel_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.children_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.children_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL VoiceTarget_Target::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const VoiceTarget_Target& this_ = static_cast<const VoiceTarget_Target&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL VoiceTarget_Target::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const VoiceTarget_Target& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.VoiceTarget.Target)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated uint32 session = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_session_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_session().Get(i), target);
    }
  }

  // optional uint32 channel_id = 2;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_channel_id(), target);
  }

  // optional string group = 3;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    const ::std::string& _s = this_._internal_group();
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional bool links = 4 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_links(), target);
  }

  // optional bool children = 5 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this_._internal_children(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.VoiceTarget.Target)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t VoiceTarget_Target::ByteSizeLong(const MessageLite& base) {
  const VoiceTarget_Target& this_ = static_cast<const VoiceTarget_Target&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t VoiceTarget_Target::ByteSizeLong() const {
  const VoiceTarget_Target& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.VoiceTarget.Target)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000018U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated uint32 session = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_session());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_session_size());
      total_size += tag_size + data_size;
    }
    // optional string group = 3;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_group());
    }
    // optional uint32 channel_id = 2;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void VoiceTarget_Target::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<VoiceTarget_Target*>(&to_msg);
  auto& from = static_cast<const VoiceTarget_Target&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.VoiceTarget.Target)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000001fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_session()->MergeFrom(from._internal_session());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_internal_set_group(from._internal_group());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.links_ = from._impl_.links_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.children_ = from._impl_.children_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void VoiceTarget_Target::CopyFrom(const VoiceTarget_Target& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.VoiceTarget.Target)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void VoiceTarget_Target::InternalSwap(VoiceTarget_Target* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.session_.InternalSwap(&other->_impl_.session_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.group_, &other->_impl_.group_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.children_)
      + sizeof(VoiceTarget_Target::_impl_.children_)
      - PROTOBUF_FIELD_OFFSET(VoiceTarget_Target, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::google::protobuf::Metadata VoiceTarget_Target::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class VoiceTarget::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<VoiceTarget>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_._has_bits_);
};

VoiceTarget::VoiceTarget(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, VoiceTarget_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.VoiceTarget)
}
PROTOBUF_NDEBUG_INLINE VoiceTarget::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::VoiceTarget& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        targets_{visibility, arena, from.targets_} {}

VoiceTarget::VoiceTarget(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const VoiceTarget& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, VoiceTarget_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  VoiceTarget* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.id_ = from._impl_.id_;

  // @@protoc_insertion_point(copy_constructor:MumbleProto.VoiceTarget)
}
PROTOBUF_NDEBUG_INLINE VoiceTarget::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        targets_{visibility, arena} {}

inline void VoiceTarget::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.id_ = {};
}
VoiceTarget::~VoiceTarget() {
  // @@protoc_insertion_point(destructor:MumbleProto.VoiceTarget)
  SharedDtor(*this);
}
inline void VoiceTarget::SharedDtor(MessageLite& self) {
  VoiceTarget& this_ = static_cast<VoiceTarget&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL VoiceTarget::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) VoiceTarget(arena);
}
constexpr auto VoiceTarget::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.targets_) +
          decltype(VoiceTarget::_impl_.targets_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(VoiceTarget), alignof(VoiceTarget), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&VoiceTarget::PlacementNew_,
                                 sizeof(VoiceTarget),
                                 alignof(VoiceTarget));
  }
}
constexpr auto VoiceTarget::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_VoiceTarget_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &VoiceTarget::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<VoiceTarget>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &VoiceTarget::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<VoiceTarget>(), &VoiceTarget::ByteSizeLong,
              &VoiceTarget::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_._cached_size_),
          false,
      },
      &VoiceTarget::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull VoiceTarget_class_data_ =
        VoiceTarget::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
VoiceTarget::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&VoiceTarget_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(VoiceTarget_class_data_.tc_table);
  return VoiceTarget_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
VoiceTarget::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    VoiceTarget_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::VoiceTarget>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .MumbleProto.VoiceTarget.Target targets = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.targets_)}},
    // optional uint32 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(VoiceTarget, _impl_.id_), 1>(),
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 id = 1;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.id_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // repeated .MumbleProto.VoiceTarget.Target targets = 2;
    {PROTOBUF_FIELD_OFFSET(VoiceTarget, _impl_.targets_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::MumbleProto::VoiceTarget_Target>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void VoiceTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.VoiceTarget)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    _impl_.targets_.Clear();
  }
  _impl_.id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL VoiceTarget::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const VoiceTarget& this_ = static_cast<const VoiceTarget&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL VoiceTarget::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const VoiceTarget& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.VoiceTarget)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_id(), target);
  }

  // repeated .MumbleProto.VoiceTarget.Target targets = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (unsigned i = 0, n = static_cast<unsigned>(
                             this_._internal_targets_size());
         i < n; i++) {
      const auto& repfield = this_._internal_targets().Get(i);
      target =
          ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
              2, repfield, repfield.GetCachedSize(),
              target, stream);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.VoiceTarget)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t VoiceTarget::ByteSizeLong(const MessageLite& base) {
  const VoiceTarget& this_ = static_cast<const VoiceTarget&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t VoiceTarget::ByteSizeLong() const {
  const VoiceTarget& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.VoiceTarget)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // repeated .MumbleProto.VoiceTarget.Target targets = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size += 1UL * this_._internal_targets_size();
      for (const auto& msg : this_._internal_targets()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
    // optional uint32 id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_id());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void VoiceTarget::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<VoiceTarget*>(&to_msg);
  auto& from = static_cast<const VoiceTarget&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.VoiceTarget)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_targets()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_targets());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.id_ = from._impl_.id_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void VoiceTarget::CopyFrom(const VoiceTarget& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.VoiceTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void VoiceTarget::InternalSwap(VoiceTarget* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.targets_.InternalSwap(&other->_impl_.targets_);
  swap(_impl_.id_, other->_impl_.id_);
}

::google::protobuf::Metadata VoiceTarget::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PermissionQuery::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<PermissionQuery>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_._has_bits_);
};

PermissionQuery::PermissionQuery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PermissionQuery_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.PermissionQuery)
}
PermissionQuery::PermissionQuery(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PermissionQuery& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, PermissionQuery_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE PermissionQuery::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void PermissionQuery::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, channel_id_),
           0,
           offsetof(Impl_, flush_) -
               offsetof(Impl_, channel_id_) +
               sizeof(Impl_::flush_));
}
PermissionQuery::~PermissionQuery() {
  // @@protoc_insertion_point(destructor:MumbleProto.PermissionQuery)
  SharedDtor(*this);
}
inline void PermissionQuery::SharedDtor(MessageLite& self) {
  PermissionQuery& this_ = static_cast<PermissionQuery&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL PermissionQuery::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) PermissionQuery(arena);
}
constexpr auto PermissionQuery::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PermissionQuery),
                                            alignof(PermissionQuery));
}
constexpr auto PermissionQuery::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_PermissionQuery_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &PermissionQuery::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<PermissionQuery>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &PermissionQuery::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<PermissionQuery>(), &PermissionQuery::ByteSizeLong,
              &PermissionQuery::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_._cached_size_),
          false,
      },
      &PermissionQuery::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull PermissionQuery_class_data_ =
        PermissionQuery::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
PermissionQuery::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&PermissionQuery_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(PermissionQuery_class_data_.tc_table);
  return PermissionQuery_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
PermissionQuery::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    PermissionQuery_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::PermissionQuery>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 channel_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionQuery, _impl_.channel_id_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.channel_id_)}},
    // optional uint32 permissions = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(PermissionQuery, _impl_.permissions_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.permissions_)}},
    // optional bool flush = 3 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(PermissionQuery, _impl_.flush_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.flush_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 channel_id = 1;
    {PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.channel_id_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 permissions = 2;
    {PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.permissions_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool flush = 3 [default = false];
    {PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.flush_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void PermissionQuery::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.PermissionQuery)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    ::memset(&_impl_.channel_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.flush_) -
        reinterpret_cast<char*>(&_impl_.channel_id_)) + sizeof(_impl_.flush_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL PermissionQuery::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const PermissionQuery& this_ = static_cast<const PermissionQuery&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL PermissionQuery::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const PermissionQuery& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.PermissionQuery)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 channel_id = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_channel_id(), target);
  }

  // optional uint32 permissions = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_permissions(), target);
  }

  // optional bool flush = 3 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_flush(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.PermissionQuery)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t PermissionQuery::ByteSizeLong(const MessageLite& base) {
  const PermissionQuery& this_ = static_cast<const PermissionQuery&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t PermissionQuery::ByteSizeLong() const {
  const PermissionQuery& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.PermissionQuery)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000004U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // optional uint32 channel_id = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_channel_id());
    }
    // optional uint32 permissions = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_permissions());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void PermissionQuery::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<PermissionQuery*>(&to_msg);
  auto& from = static_cast<const PermissionQuery&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.PermissionQuery)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.permissions_ = from._impl_.permissions_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.flush_ = from._impl_.flush_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void PermissionQuery::CopyFrom(const PermissionQuery& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.PermissionQuery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PermissionQuery::InternalSwap(PermissionQuery* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.flush_)
      + sizeof(PermissionQuery::_impl_.flush_)
      - PROTOBUF_FIELD_OFFSET(PermissionQuery, _impl_.channel_id_)>(
          reinterpret_cast<char*>(&_impl_.channel_id_),
          reinterpret_cast<char*>(&other->_impl_.channel_id_));
}

::google::protobuf::Metadata PermissionQuery::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CodecVersion::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<CodecVersion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_._has_bits_);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000b) ^ 0x0000000b) != 0;
  }
};

CodecVersion::CodecVersion(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CodecVersion_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.CodecVersion)
}
CodecVersion::CodecVersion(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CodecVersion& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, CodecVersion_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE CodecVersion::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        prefer_alpha_{true} {}

inline void CodecVersion::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, alpha_),
           0,
           offsetof(Impl_, opus_) -
               offsetof(Impl_, alpha_) +
               sizeof(Impl_::opus_));
}
CodecVersion::~CodecVersion() {
  // @@protoc_insertion_point(destructor:MumbleProto.CodecVersion)
  SharedDtor(*this);
}
inline void CodecVersion::SharedDtor(MessageLite& self) {
  CodecVersion& this_ = static_cast<CodecVersion&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL CodecVersion::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) CodecVersion(arena);
}
constexpr auto CodecVersion::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(CodecVersion),
                                            alignof(CodecVersion));
}
constexpr auto CodecVersion::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_CodecVersion_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          CodecVersion::IsInitializedImpl,
          &CodecVersion::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<CodecVersion>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &CodecVersion::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<CodecVersion>(), &CodecVersion::ByteSizeLong,
              &CodecVersion::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_._cached_size_),
          false,
      },
      &CodecVersion::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull CodecVersion_class_data_ =
        CodecVersion::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
CodecVersion::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&CodecVersion_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(CodecVersion_class_data_.tc_table);
  return CodecVersion_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
CodecVersion::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    CodecVersion_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::CodecVersion>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional bool opus = 4 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CodecVersion, _impl_.opus_), 2>(),
     {32, 2, 0,
      PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.opus_)}},
    // required int32 alpha = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CodecVersion, _impl_.alpha_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.alpha_)}},
    // required int32 beta = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CodecVersion, _impl_.beta_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.beta_)}},
    // required bool prefer_alpha = 3 [default = true];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CodecVersion, _impl_.prefer_alpha_), 3>(),
     {24, 3, 0,
      PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.prefer_alpha_)}},
  }}, {{
    65535, 65535
  }}, {{
    // required int32 alpha = 1;
    {PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.alpha_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // required int32 beta = 2;
    {PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.beta_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // required bool prefer_alpha = 3 [default = true];
    {PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.prefer_alpha_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool opus = 4 [default = false];
    {PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.opus_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void CodecVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.CodecVersion)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    ::memset(&_impl_.alpha_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.opus_) -
        reinterpret_cast<char*>(&_impl_.alpha_)) + sizeof(_impl_.opus_));
    _impl_.prefer_alpha_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL CodecVersion::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const CodecVersion& this_ = static_cast<const CodecVersion&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL CodecVersion::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const CodecVersion& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.CodecVersion)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // required int32 alpha = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
            stream, this_._internal_alpha(), target);
  }

  // required int32 beta = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<2>(
            stream, this_._internal_beta(), target);
  }

  // required bool prefer_alpha = 3 [default = true];
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_prefer_alpha(), target);
  }

  // optional bool opus = 4 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this_._internal_opus(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.CodecVersion)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t CodecVersion::ByteSizeLong(const MessageLite& base) {
  const CodecVersion& this_ = static_cast<const CodecVersion&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t CodecVersion::ByteSizeLong() const {
  const CodecVersion& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.CodecVersion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x0000000cU & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x00000003U)) {
    // required int32 alpha = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_alpha());
    }
    // required int32 beta = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_beta());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void CodecVersion::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<CodecVersion*>(&to_msg);
  auto& from = static_cast<const CodecVersion&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.CodecVersion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.alpha_ = from._impl_.alpha_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.beta_ = from._impl_.beta_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.opus_ = from._impl_.opus_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.prefer_alpha_ = from._impl_.prefer_alpha_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void CodecVersion::CopyFrom(const CodecVersion& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.CodecVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CodecVersion::IsInitializedImpl(
    const MessageLite& msg) {
  auto& this_ = static_cast<const CodecVersion&>(msg);
  if (_Internal::MissingRequiredFields(this_._impl_._has_bits_)) {
    return false;
  }
  return true;
}

void CodecVersion::InternalSwap(CodecVersion* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.prefer_alpha_)
      + sizeof(CodecVersion::_impl_.prefer_alpha_)
      - PROTOBUF_FIELD_OFFSET(CodecVersion, _impl_.alpha_)>(
          reinterpret_cast<char*>(&_impl_.alpha_),
          reinterpret_cast<char*>(&other->_impl_.alpha_));
}

::google::protobuf::Metadata CodecVersion::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserStats_Stats::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserStats_Stats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_._has_bits_);
};

UserStats_Stats::UserStats_Stats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_Stats_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.UserStats.Stats)
}
UserStats_Stats::UserStats_Stats(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserStats_Stats& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_Stats_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE UserStats_Stats::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void UserStats_Stats::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, good_),
           0,
           offsetof(Impl_, resync_) -
               offsetof(Impl_, good_) +
               sizeof(Impl_::resync_));
}
UserStats_Stats::~UserStats_Stats() {
  // @@protoc_insertion_point(destructor:MumbleProto.UserStats.Stats)
  SharedDtor(*this);
}
inline void UserStats_Stats::SharedDtor(MessageLite& self) {
  UserStats_Stats& this_ = static_cast<UserStats_Stats&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserStats_Stats::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserStats_Stats(arena);
}
constexpr auto UserStats_Stats::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(UserStats_Stats),
                                            alignof(UserStats_Stats));
}
constexpr auto UserStats_Stats::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserStats_Stats_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UserStats_Stats::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserStats_Stats>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserStats_Stats::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserStats_Stats>(), &UserStats_Stats::ByteSizeLong,
              &UserStats_Stats::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_._cached_size_),
          false,
      },
      &UserStats_Stats::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserStats_Stats_class_data_ =
        UserStats_Stats::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserStats_Stats::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserStats_Stats_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserStats_Stats_class_data_.tc_table);
  return UserStats_Stats_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
UserStats_Stats::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    UserStats_Stats_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::UserStats_Stats>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint32 resync = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_Stats, _impl_.resync_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.resync_)}},
    // optional uint32 good = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_Stats, _impl_.good_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.good_)}},
    // optional uint32 late = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_Stats, _impl_.late_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.late_)}},
    // optional uint32 lost = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats_Stats, _impl_.lost_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.lost_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 good = 1;
    {PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.good_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 late = 2;
    {PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.late_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 lost = 3;
    {PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.lost_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 resync = 4;
    {PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.resync_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void UserStats_Stats::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.UserStats.Stats)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    ::memset(&_impl_.good_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.resync_) -
        reinterpret_cast<char*>(&_impl_.good_)) + sizeof(_impl_.resync_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserStats_Stats::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserStats_Stats& this_ = static_cast<const UserStats_Stats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserStats_Stats::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserStats_Stats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.UserStats.Stats)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 good = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_good(), target);
  }

  // optional uint32 late = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this_._internal_late(), target);
  }

  // optional uint32 lost = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this_._internal_lost(), target);
  }

  // optional uint32 resync = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_resync(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.UserStats.Stats)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserStats_Stats::ByteSizeLong(const MessageLite& base) {
  const UserStats_Stats& this_ = static_cast<const UserStats_Stats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserStats_Stats::ByteSizeLong() const {
  const UserStats_Stats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.UserStats.Stats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    // optional uint32 good = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_good());
    }
    // optional uint32 late = 2;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_late());
    }
    // optional uint32 lost = 3;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_lost());
    }
    // optional uint32 resync = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_resync());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserStats_Stats::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<UserStats_Stats*>(&to_msg);
  auto& from = static_cast<const UserStats_Stats&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.UserStats.Stats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000000fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.good_ = from._impl_.good_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.late_ = from._impl_.late_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.lost_ = from._impl_.lost_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.resync_ = from._impl_.resync_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void UserStats_Stats::CopyFrom(const UserStats_Stats& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.UserStats.Stats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UserStats_Stats::InternalSwap(UserStats_Stats* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.resync_)
      + sizeof(UserStats_Stats::_impl_.resync_)
      - PROTOBUF_FIELD_OFFSET(UserStats_Stats, _impl_.good_)>(
          reinterpret_cast<char*>(&_impl_.good_),
          reinterpret_cast<char*>(&other->_impl_.good_));
}

::google::protobuf::Metadata UserStats_Stats::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class UserStats::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<UserStats>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(UserStats, _impl_._has_bits_);
};

UserStats::UserStats(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.UserStats)
}
PROTOBUF_NDEBUG_INLINE UserStats::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::UserStats& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        certificates_{visibility, arena, from.certificates_},
        celt_versions_{visibility, arena, from.celt_versions_},
        address_(arena, from.address_) {}

UserStats::UserStats(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const UserStats& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, UserStats_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  UserStats* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.from_client_ = (CheckHasBit(cached_has_bits, 0x00000008U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_client_)
                : nullptr;
  _impl_.from_server_ = (CheckHasBit(cached_has_bits, 0x00000010U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_server_)
                : nullptr;
  _impl_.version_ = (CheckHasBit(cached_has_bits, 0x00000020U))
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.version_)
                : nullptr;
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, session_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, session_),
           offsetof(Impl_, idlesecs_) -
               offsetof(Impl_, session_) +
               sizeof(Impl_::idlesecs_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.UserStats)
}
PROTOBUF_NDEBUG_INLINE UserStats::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        certificates_{visibility, arena},
        celt_versions_{visibility, arena},
        address_(arena) {}

inline void UserStats::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, from_client_),
           0,
           offsetof(Impl_, idlesecs_) -
               offsetof(Impl_, from_client_) +
               sizeof(Impl_::idlesecs_));
}
UserStats::~UserStats() {
  // @@protoc_insertion_point(destructor:MumbleProto.UserStats)
  SharedDtor(*this);
}
inline void UserStats::SharedDtor(MessageLite& self) {
  UserStats& this_ = static_cast<UserStats&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.address_.Destroy();
  delete this_._impl_.from_client_;
  delete this_._impl_.from_server_;
  delete this_._impl_.version_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL UserStats::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) UserStats(arena);
}
constexpr auto UserStats::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.certificates_) +
          decltype(UserStats::_impl_.certificates_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.celt_versions_) +
          decltype(UserStats::_impl_.celt_versions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(UserStats), alignof(UserStats), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&UserStats::PlacementNew_,
                                 sizeof(UserStats),
                                 alignof(UserStats));
  }
}
constexpr auto UserStats::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_UserStats_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &UserStats::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<UserStats>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &UserStats::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<UserStats>(), &UserStats::ByteSizeLong,
              &UserStats::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(UserStats, _impl_._cached_size_),
          false,
      },
      &UserStats::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull UserStats_class_data_ =
        UserStats::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
UserStats::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&UserStats_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(UserStats_class_data_.tc_table);
  return UserStats_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 19, 3, 0, 2>
UserStats::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UserStats, _impl_._has_bits_),
    0, // no _extensions_
    19, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294443008,  // skipmap
    offsetof(decltype(_table_), field_entries),
    19,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    UserStats_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::UserStats>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 session = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats, _impl_.session_), 6>(),
     {8, 6, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.session_)}},
    // optional bool stats_only = 2 [default = false];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(UserStats, _impl_.stats_only_), 13>(),
     {16, 13, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.stats_only_)}},
    // repeated bytes certificates = 3;
    {::_pbi::TcParser::FastBR1,
     {26, 0, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.certificates_)}},
    // optional .MumbleProto.UserStats.Stats from_client = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_client_)}},
    // optional .MumbleProto.UserStats.Stats from_server = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 4, 1,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_server_)}},
    // optional uint32 udp_packets = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats, _impl_.udp_packets_), 7>(),
     {48, 7, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_packets_)}},
    // optional uint32 tcp_packets = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats, _impl_.tcp_packets_), 8>(),
     {56, 8, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_packets_)}},
    // optional float udp_ping_avg = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 9, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_ping_avg_)}},
    // optional float udp_ping_var = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 10, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_ping_var_)}},
    // optional float tcp_ping_avg = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 11, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_ping_avg_)}},
    // optional float tcp_ping_var = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 12, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_ping_var_)}},
    // optional .MumbleProto.Version version = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 5, 2,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.version_)}},
    // repeated int32 celt_versions = 13;
    {::_pbi::TcParser::FastV32R1,
     {104, 1, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.celt_versions_)}},
    // optional bytes address = 14;
    {::_pbi::TcParser::FastBS1,
     {114, 2, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.address_)}},
    // optional uint32 bandwidth = 15;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UserStats, _impl_.bandwidth_), 16>(),
     {120, 16, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.bandwidth_)}},
    // optional uint32 onlinesecs = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 17, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.onlinesecs_)}},
    // optional uint32 idlesecs = 17;
    {::_pbi::TcParser::FastV32S2,
     {392, 18, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.idlesecs_)}},
    // optional bool strong_certificate = 18 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {400, 14, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.strong_certificate_)}},
    // optional bool opus = 19 [default = false];
    {::_pbi::TcParser::FastV8S2,
     {408, 15, 0,
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.opus_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 session = 1;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.session_), _Internal::kHasBitsOffset + 6, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool stats_only = 2 [default = false];
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.stats_only_), _Internal::kHasBitsOffset + 13, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated bytes certificates = 3;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.certificates_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // optional .MumbleProto.UserStats.Stats from_client = 4;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_client_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .MumbleProto.UserStats.Stats from_server = 5;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_server_), _Internal::kHasBitsOffset + 4, 1, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional uint32 udp_packets = 6;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_packets_), _Internal::kHasBitsOffset + 7, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 tcp_packets = 7;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_packets_), _Internal::kHasBitsOffset + 8, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional float udp_ping_avg = 8;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_ping_avg_), _Internal::kHasBitsOffset + 9, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float udp_ping_var = 9;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.udp_ping_var_), _Internal::kHasBitsOffset + 10, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float tcp_ping_avg = 10;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_ping_avg_), _Internal::kHasBitsOffset + 11, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional float tcp_ping_var = 11;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.tcp_ping_var_), _Internal::kHasBitsOffset + 12, 0, (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // optional .MumbleProto.Version version = 12;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.version_), _Internal::kHasBitsOffset + 5, 2, (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated int32 celt_versions = 13;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.celt_versions_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kInt32)},
    // optional bytes address = 14;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.address_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 bandwidth = 15;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.bandwidth_), _Internal::kHasBitsOffset + 16, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 onlinesecs = 16;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.onlinesecs_), _Internal::kHasBitsOffset + 17, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 idlesecs = 17;
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.idlesecs_), _Internal::kHasBitsOffset + 18, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool strong_certificate = 18 [default = false];
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.strong_certificate_), _Internal::kHasBitsOffset + 14, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool opus = 19 [default = false];
    {PROTOBUF_FIELD_OFFSET(UserStats, _impl_.opus_), _Internal::kHasBitsOffset + 15, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::MumbleProto::UserStats_Stats>()},
      {::_pbi::TcParser::GetTable<::MumbleProto::UserStats_Stats>()},
      {::_pbi::TcParser::GetTable<::MumbleProto::Version>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void UserStats::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.UserStats)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.certificates_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.celt_versions_.Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(_impl_.from_client_ != nullptr);
      _impl_.from_client_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(_impl_.from_server_ != nullptr);
      _impl_.from_server_->Clear();
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(_impl_.version_ != nullptr);
      _impl_.version_->Clear();
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x000000c0U)) {
    ::memset(&_impl_.session_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.udp_packets_) -
        reinterpret_cast<char*>(&_impl_.session_)) + sizeof(_impl_.udp_packets_));
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    ::memset(&_impl_.tcp_packets_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.opus_) -
        reinterpret_cast<char*>(&_impl_.tcp_packets_)) + sizeof(_impl_.opus_));
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00070000U)) {
    ::memset(&_impl_.bandwidth_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.idlesecs_) -
        reinterpret_cast<char*>(&_impl_.bandwidth_)) + sizeof(_impl_.idlesecs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL UserStats::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const UserStats& this_ = static_cast<const UserStats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL UserStats::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const UserStats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.UserStats)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 session = 1;
  if (CheckHasBit(cached_has_bits, 0x00000040U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_session(), target);
  }

  // optional bool stats_only = 2 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00002000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_stats_only(), target);
  }

  // repeated bytes certificates = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_certificates_size(); i < n; ++i) {
      const auto& s = this_._internal_certificates().Get(i);
      target = stream->WriteBytes(3, s, target);
    }
  }

  // optional .MumbleProto.UserStats.Stats from_client = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, *this_._impl_.from_client_, this_._impl_.from_client_->GetCachedSize(), target,
        stream);
  }

  // optional .MumbleProto.UserStats.Stats from_server = 5;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, *this_._impl_.from_server_, this_._impl_.from_server_->GetCachedSize(), target,
        stream);
  }

  // optional uint32 udp_packets = 6;
  if (CheckHasBit(cached_has_bits, 0x00000080U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_udp_packets(), target);
  }

  // optional uint32 tcp_packets = 7;
  if (CheckHasBit(cached_has_bits, 0x00000100U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this_._internal_tcp_packets(), target);
  }

  // optional float udp_ping_avg = 8;
  if (CheckHasBit(cached_has_bits, 0x00000200U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this_._internal_udp_ping_avg(), target);
  }

  // optional float udp_ping_var = 9;
  if (CheckHasBit(cached_has_bits, 0x00000400U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this_._internal_udp_ping_var(), target);
  }

  // optional float tcp_ping_avg = 10;
  if (CheckHasBit(cached_has_bits, 0x00000800U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this_._internal_tcp_ping_avg(), target);
  }

  // optional float tcp_ping_var = 11;
  if (CheckHasBit(cached_has_bits, 0x00001000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this_._internal_tcp_ping_var(), target);
  }

  // optional .MumbleProto.Version version = 12;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        12, *this_._impl_.version_, this_._impl_.version_->GetCachedSize(), target,
        stream);
  }

  // repeated int32 celt_versions = 13;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (int i = 0, n = this_._internal_celt_versions_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt32ToArray(
          13, this_._internal_celt_versions().Get(i), target);
    }
  }

  // optional bytes address = 14;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    const ::std::string& _s = this_._internal_address();
    target = stream->WriteBytesMaybeAliased(14, _s, target);
  }

  // optional uint32 bandwidth = 15;
  if (CheckHasBit(cached_has_bits, 0x00010000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this_._internal_bandwidth(), target);
  }

  // optional uint32 onlinesecs = 16;
  if (CheckHasBit(cached_has_bits, 0x00020000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this_._internal_onlinesecs(), target);
  }

  // optional uint32 idlesecs = 17;
  if (CheckHasBit(cached_has_bits, 0x00040000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        17, this_._internal_idlesecs(), target);
  }

  // optional bool strong_certificate = 18 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00004000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        18, this_._internal_strong_certificate(), target);
  }

  // optional bool opus = 19 [default = false];
  if (CheckHasBit(cached_has_bits, 0x00008000U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        19, this_._internal_opus(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.UserStats)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t UserStats::ByteSizeLong(const MessageLite& base) {
  const UserStats& this_ = static_cast<const UserStats&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t UserStats::ByteSizeLong() const {
  const UserStats& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.UserStats)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00001e00U & cached_has_bits) * 5;
  total_size += ::absl::popcount(0x0000c000U & cached_has_bits) * 3;
  total_size += static_cast<bool>(0x00002000U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    // repeated bytes certificates = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_certificates().size());
      for (int i = 0, n = this_._internal_certificates().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
            this_._internal_certificates().Get(i));
      }
    }
    // repeated int32 celt_versions = 13;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
          this_._internal_celt_versions());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_celt_versions_size());
      total_size += tag_size + data_size;
    }
    // optional bytes address = 14;
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_address());
    }
    // optional .MumbleProto.UserStats.Stats from_client = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.from_client_);
    }
    // optional .MumbleProto.UserStats.Stats from_server = 5;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.from_server_);
    }
    // optional .MumbleProto.Version version = 12;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.version_);
    }
    // optional uint32 session = 1;
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_session());
    }
    // optional uint32 udp_packets = 6;
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_udp_packets());
    }
  }
   {
    // optional uint32 tcp_packets = 7;
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_tcp_packets());
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00070000U)) {
    // optional uint32 bandwidth = 15;
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_bandwidth());
    }
    // optional uint32 onlinesecs = 16;
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this_._internal_onlinesecs());
    }
    // optional uint32 idlesecs = 17;
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this_._internal_idlesecs());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void UserStats::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<UserStats*>(&to_msg);
  auto& from = static_cast<const UserStats&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.UserStats)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x000000ffU)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_certificates()->InternalMergeFromWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), arena,
          from._internal_certificates());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_celt_versions()->MergeFrom(from._internal_celt_versions());
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_internal_set_address(from._internal_address());
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      ABSL_DCHECK(from._impl_.from_client_ != nullptr);
      if (_this->_impl_.from_client_ == nullptr) {
        _this->_impl_.from_client_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_client_);
      } else {
        _this->_impl_.from_client_->MergeFrom(*from._impl_.from_client_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      ABSL_DCHECK(from._impl_.from_server_ != nullptr);
      if (_this->_impl_.from_server_ == nullptr) {
        _this->_impl_.from_server_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.from_server_);
      } else {
        _this->_impl_.from_server_->MergeFrom(*from._impl_.from_server_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      ABSL_DCHECK(from._impl_.version_ != nullptr);
      if (_this->_impl_.version_ == nullptr) {
        _this->_impl_.version_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.version_);
      } else {
        _this->_impl_.version_->MergeFrom(*from._impl_.version_);
      }
    }
    if (CheckHasBit(cached_has_bits, 0x00000040U)) {
      _this->_impl_.session_ = from._impl_.session_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000080U)) {
      _this->_impl_.udp_packets_ = from._impl_.udp_packets_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000ff00U)) {
    if (CheckHasBit(cached_has_bits, 0x00000100U)) {
      _this->_impl_.tcp_packets_ = from._impl_.tcp_packets_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000200U)) {
      _this->_impl_.udp_ping_avg_ = from._impl_.udp_ping_avg_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000400U)) {
      _this->_impl_.udp_ping_var_ = from._impl_.udp_ping_var_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000800U)) {
      _this->_impl_.tcp_ping_avg_ = from._impl_.tcp_ping_avg_;
    }
    if (CheckHasBit(cached_has_bits, 0x00001000U)) {
      _this->_impl_.tcp_ping_var_ = from._impl_.tcp_ping_var_;
    }
    if (CheckHasBit(cached_has_bits, 0x00002000U)) {
      _this->_impl_.stats_only_ = from._impl_.stats_only_;
    }
    if (CheckHasBit(cached_has_bits, 0x00004000U)) {
      _this->_impl_.strong_certificate_ = from._impl_.strong_certificate_;
    }
    if (CheckHasBit(cached_has_bits, 0x00008000U)) {
      _this->_impl_.opus_ = from._impl_.opus_;
    }
  }
  if (BatchCheckHasBit(cached_has_bits, 0x00070000U)) {
    if (CheckHasBit(cached_has_bits, 0x00010000U)) {
      _this->_impl_.bandwidth_ = from._impl_.bandwidth_;
    }
    if (CheckHasBit(cached_has_bits, 0x00020000U)) {
      _this->_impl_.onlinesecs_ = from._impl_.onlinesecs_;
    }
    if (CheckHasBit(cached_has_bits, 0x00040000U)) {
      _this->_impl_.idlesecs_ = from._impl_.idlesecs_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void UserStats::CopyFrom(const UserStats& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.UserStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void UserStats::InternalSwap(UserStats* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.certificates_.InternalSwap(&other->_impl_.certificates_);
  _impl_.celt_versions_.InternalSwap(&other->_impl_.celt_versions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.address_, &other->_impl_.address_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserStats, _impl_.idlesecs_)
      + sizeof(UserStats::_impl_.idlesecs_)
      - PROTOBUF_FIELD_OFFSET(UserStats, _impl_.from_client_)>(
          reinterpret_cast<char*>(&_impl_.from_client_),
          reinterpret_cast<char*>(&other->_impl_.from_client_));
}

::google::protobuf::Metadata UserStats::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RequestBlob::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RequestBlob>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_._has_bits_);
};

RequestBlob::RequestBlob(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RequestBlob_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.RequestBlob)
}
PROTOBUF_NDEBUG_INLINE RequestBlob::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::RequestBlob& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        session_texture_{visibility, arena, from.session_texture_},
        session_comment_{visibility, arena, from.session_comment_},
        channel_description_{visibility, arena, from.channel_description_} {}

RequestBlob::RequestBlob(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RequestBlob& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RequestBlob_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RequestBlob* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:MumbleProto.RequestBlob)
}
PROTOBUF_NDEBUG_INLINE RequestBlob::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        session_texture_{visibility, arena},
        session_comment_{visibility, arena},
        channel_description_{visibility, arena} {}

inline void RequestBlob::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
RequestBlob::~RequestBlob() {
  // @@protoc_insertion_point(destructor:MumbleProto.RequestBlob)
  SharedDtor(*this);
}
inline void RequestBlob::SharedDtor(MessageLite& self) {
  RequestBlob& this_ = static_cast<RequestBlob&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RequestBlob::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RequestBlob(arena);
}
constexpr auto RequestBlob::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_texture_) +
          decltype(RequestBlob::_impl_.session_texture_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_comment_) +
          decltype(RequestBlob::_impl_.session_comment_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.channel_description_) +
          decltype(RequestBlob::_impl_.channel_description_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RequestBlob), alignof(RequestBlob), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RequestBlob::PlacementNew_,
                                 sizeof(RequestBlob),
                                 alignof(RequestBlob));
  }
}
constexpr auto RequestBlob::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RequestBlob_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RequestBlob::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RequestBlob>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RequestBlob::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RequestBlob>(), &RequestBlob::ByteSizeLong,
              &RequestBlob::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_._cached_size_),
          false,
      },
      &RequestBlob::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RequestBlob_class_data_ =
        RequestBlob::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RequestBlob::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RequestBlob_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RequestBlob_class_data_.tc_table);
  return RequestBlob_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
RequestBlob::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    RequestBlob_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::RequestBlob>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated uint32 session_texture = 1;
    {::_pbi::TcParser::FastV32R1,
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_texture_)}},
    // repeated uint32 session_comment = 2;
    {::_pbi::TcParser::FastV32R1,
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_comment_)}},
    // repeated uint32 channel_description = 3;
    {::_pbi::TcParser::FastV32R1,
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.channel_description_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 session_texture = 1;
    {PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_texture_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 session_comment = 2;
    {PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.session_comment_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
    // repeated uint32 channel_description = 3;
    {PROTOBUF_FIELD_OFFSET(RequestBlob, _impl_.channel_description_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcRepeated | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void RequestBlob::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.RequestBlob)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _impl_.session_texture_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _impl_.session_comment_.Clear();
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _impl_.channel_description_.Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RequestBlob::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RequestBlob& this_ = static_cast<const RequestBlob&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RequestBlob::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RequestBlob& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.RequestBlob)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // repeated uint32 session_texture = 1;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
    for (int i = 0, n = this_._internal_session_texture_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_session_texture().Get(i), target);
    }
  }

  // repeated uint32 session_comment = 2;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
    for (int i = 0, n = this_._internal_session_comment_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this_._internal_session_comment().Get(i), target);
    }
  }

  // repeated uint32 channel_description = 3;
  if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
    for (int i = 0, n = this_._internal_channel_description_size(); i < n; ++i) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this_._internal_channel_description().Get(i), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.RequestBlob)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RequestBlob::ByteSizeLong(const MessageLite& base) {
  const RequestBlob& this_ = static_cast<const RequestBlob&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RequestBlob::ByteSizeLong() const {
  const RequestBlob& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.RequestBlob)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    // repeated uint32 session_texture = 1;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_session_texture());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_session_texture_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 session_comment = 2;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_session_comment());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_session_comment_size());
      total_size += tag_size + data_size;
    }
    // repeated uint32 channel_description = 3;
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      ::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
          this_._internal_channel_description());
      ::size_t tag_size = ::size_t{1} *
          ::_pbi::FromIntSize(this_._internal_channel_description_size());
      total_size += tag_size + data_size;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RequestBlob::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<RequestBlob*>(&to_msg);
  auto& from = static_cast<const RequestBlob&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.RequestBlob)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000001U)) {
      _this->_internal_mutable_session_texture()->MergeFrom(from._internal_session_texture());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000002U)) {
      _this->_internal_mutable_session_comment()->MergeFrom(from._internal_session_comment());
    }
    if (CheckHasBitForRepeated(cached_has_bits, 0x00000004U)) {
      _this->_internal_mutable_channel_description()->MergeFrom(from._internal_channel_description());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void RequestBlob::CopyFrom(const RequestBlob& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.RequestBlob)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RequestBlob::InternalSwap(RequestBlob* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.session_texture_.InternalSwap(&other->_impl_.session_texture_);
  _impl_.session_comment_.InternalSwap(&other->_impl_.session_comment_);
  _impl_.channel_description_.InternalSwap(&other->_impl_.channel_description_);
}

::google::protobuf::Metadata RequestBlob::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ServerConfig::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ServerConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_._has_bits_);
};

ServerConfig::ServerConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ServerConfig_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.ServerConfig)
}
PROTOBUF_NDEBUG_INLINE ServerConfig::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    [[maybe_unused]] const ::MumbleProto::ServerConfig& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        welcome_text_(arena, from.welcome_text_) {}

ServerConfig::ServerConfig(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ServerConfig& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ServerConfig_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ServerConfig* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, max_bandwidth_),
           reinterpret_cast<const char*>(&from._impl_) +
               offsetof(Impl_, max_bandwidth_),
           offsetof(Impl_, max_users_) -
               offsetof(Impl_, max_bandwidth_) +
               sizeof(Impl_::max_users_));

  // @@protoc_insertion_point(copy_constructor:MumbleProto.ServerConfig)
}
PROTOBUF_NDEBUG_INLINE ServerConfig::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        welcome_text_(arena) {}

inline void ServerConfig::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, max_bandwidth_),
           0,
           offsetof(Impl_, max_users_) -
               offsetof(Impl_, max_bandwidth_) +
               sizeof(Impl_::max_users_));
}
ServerConfig::~ServerConfig() {
  // @@protoc_insertion_point(destructor:MumbleProto.ServerConfig)
  SharedDtor(*this);
}
inline void ServerConfig::SharedDtor(MessageLite& self) {
  ServerConfig& this_ = static_cast<ServerConfig&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.welcome_text_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ServerConfig::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ServerConfig(arena);
}
constexpr auto ServerConfig::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ServerConfig),
                                            alignof(ServerConfig));
}
constexpr auto ServerConfig::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ServerConfig_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ServerConfig::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ServerConfig>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ServerConfig::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ServerConfig>(), &ServerConfig::ByteSizeLong,
              &ServerConfig::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_._cached_size_),
          false,
      },
      &ServerConfig::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ServerConfig_class_data_ =
        ServerConfig::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ServerConfig::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ServerConfig_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ServerConfig_class_data_.tc_table);
  return ServerConfig_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2>
ServerConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ServerConfig_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::ServerConfig>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 max_bandwidth = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerConfig, _impl_.max_bandwidth_), 1>(),
     {8, 1, 0,
      PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_bandwidth_)}},
    // optional string welcome_text = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0,
      PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.welcome_text_)}},
    // optional bool allow_html = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ServerConfig, _impl_.allow_html_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.allow_html_)}},
    // optional uint32 message_length = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerConfig, _impl_.message_length_), 3>(),
     {32, 3, 0,
      PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.message_length_)}},
    // optional uint32 image_message_length = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerConfig, _impl_.image_message_length_), 4>(),
     {40, 4, 0,
      PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.image_message_length_)}},
    // optional uint32 max_users = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ServerConfig, _impl_.max_users_), 5>(),
     {48, 5, 0,
      PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_users_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 max_bandwidth = 1;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_bandwidth_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional string welcome_text = 2;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.welcome_text_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool allow_html = 3;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.allow_html_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 message_length = 4;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.message_length_), _Internal::kHasBitsOffset + 3, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 image_message_length = 5;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.image_message_length_), _Internal::kHasBitsOffset + 4, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 max_users = 6;
    {PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_users_), _Internal::kHasBitsOffset + 5, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ServerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.ServerConfig)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    _impl_.welcome_text_.ClearNonDefaultToEmpty();
  }
  if (BatchCheckHasBit(cached_has_bits, 0x0000003eU)) {
    ::memset(&_impl_.max_bandwidth_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_users_) -
        reinterpret_cast<char*>(&_impl_.max_bandwidth_)) + sizeof(_impl_.max_users_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ServerConfig::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ServerConfig& this_ = static_cast<const ServerConfig&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ServerConfig::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ServerConfig& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.ServerConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 max_bandwidth = 1;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_max_bandwidth(), target);
  }

  // optional string welcome_text = 2;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    const ::std::string& _s = this_._internal_welcome_text();
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional bool allow_html = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_allow_html(), target);
  }

  // optional uint32 message_length = 4;
  if (CheckHasBit(cached_has_bits, 0x00000008U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this_._internal_message_length(), target);
  }

  // optional uint32 image_message_length = 5;
  if (CheckHasBit(cached_has_bits, 0x00000010U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this_._internal_image_message_length(), target);
  }

  // optional uint32 max_users = 6;
  if (CheckHasBit(cached_has_bits, 0x00000020U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this_._internal_max_users(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.ServerConfig)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ServerConfig::ByteSizeLong(const MessageLite& base) {
  const ServerConfig& this_ = static_cast<const ServerConfig&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ServerConfig::ByteSizeLong() const {
  const ServerConfig& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.ServerConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000004U & cached_has_bits) * 2;
  if (BatchCheckHasBit(cached_has_bits, 0x0000003bU)) {
    // optional string welcome_text = 2;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_welcome_text());
    }
    // optional uint32 max_bandwidth = 1;
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_max_bandwidth());
    }
    // optional uint32 message_length = 4;
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_message_length());
    }
    // optional uint32 image_message_length = 5;
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_image_message_length());
    }
    // optional uint32 max_users = 6;
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_max_users());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ServerConfig::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<ServerConfig*>(&to_msg);
  auto& from = static_cast<const ServerConfig&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.ServerConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x0000003fU)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_internal_set_welcome_text(from._internal_welcome_text());
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.max_bandwidth_ = from._impl_.max_bandwidth_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.allow_html_ = from._impl_.allow_html_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000008U)) {
      _this->_impl_.message_length_ = from._impl_.message_length_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000010U)) {
      _this->_impl_.image_message_length_ = from._impl_.image_message_length_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000020U)) {
      _this->_impl_.max_users_ = from._impl_.max_users_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void ServerConfig::CopyFrom(const ServerConfig& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.ServerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ServerConfig::InternalSwap(ServerConfig* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.welcome_text_, &other->_impl_.welcome_text_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_users_)
      + sizeof(ServerConfig::_impl_.max_users_)
      - PROTOBUF_FIELD_OFFSET(ServerConfig, _impl_.max_bandwidth_)>(
          reinterpret_cast<char*>(&_impl_.max_bandwidth_),
          reinterpret_cast<char*>(&other->_impl_.max_bandwidth_));
}

::google::protobuf::Metadata ServerConfig::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SuggestConfig::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SuggestConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_._has_bits_);
};

SuggestConfig::SuggestConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SuggestConfig_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MumbleProto.SuggestConfig)
}
SuggestConfig::SuggestConfig(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SuggestConfig& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SuggestConfig_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE SuggestConfig::Impl_::Impl_(
    [[maybe_unused]] ::google::protobuf::internal::InternalVisibility visibility,
    [[maybe_unused]] ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void SuggestConfig::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char*>(&_impl_) +
               offsetof(Impl_, version_),
           0,
           offsetof(Impl_, push_to_talk_) -
               offsetof(Impl_, version_) +
               sizeof(Impl_::push_to_talk_));
}
SuggestConfig::~SuggestConfig() {
  // @@protoc_insertion_point(destructor:MumbleProto.SuggestConfig)
  SharedDtor(*this);
}
inline void SuggestConfig::SharedDtor(MessageLite& self) {
  SuggestConfig& this_ = static_cast<SuggestConfig&>(self);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SuggestConfig::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SuggestConfig(arena);
}
constexpr auto SuggestConfig::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(SuggestConfig),
                                            alignof(SuggestConfig));
}
constexpr auto SuggestConfig::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SuggestConfig_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SuggestConfig::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SuggestConfig>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SuggestConfig::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SuggestConfig>(), &SuggestConfig::ByteSizeLong,
              &SuggestConfig::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_._cached_size_),
          false,
      },
      &SuggestConfig::kDescriptorMethods,
      &descriptor_table_Mumble_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SuggestConfig_class_data_ =
        SuggestConfig::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SuggestConfig::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SuggestConfig_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SuggestConfig_class_data_.tc_table);
  return SuggestConfig_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
SuggestConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SuggestConfig_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::MumbleProto::SuggestConfig>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 version = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SuggestConfig, _impl_.version_), 0>(),
     {8, 0, 0,
      PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_)}},
    // optional bool positional = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SuggestConfig, _impl_.positional_), 1>(),
     {16, 1, 0,
      PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.positional_)}},
    // optional bool push_to_talk = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SuggestConfig, _impl_.push_to_talk_), 2>(),
     {24, 2, 0,
      PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.push_to_talk_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 version = 1;
    {PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_), _Internal::kHasBitsOffset + 0, 0, (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool positional = 2;
    {PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.positional_), _Internal::kHasBitsOffset + 1, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool push_to_talk = 3;
    {PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.push_to_talk_), _Internal::kHasBitsOffset + 2, 0, (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void SuggestConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:MumbleProto.SuggestConfig)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    ::memset(&_impl_.version_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.push_to_talk_) -
        reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.push_to_talk_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SuggestConfig::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SuggestConfig& this_ = static_cast<const SuggestConfig&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SuggestConfig::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SuggestConfig& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    this_.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(serialize_to_array_start:MumbleProto.SuggestConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (CheckHasBit(cached_has_bits, 0x00000001U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_version(), target);
  }

  // optional bool positional = 2;
  if (CheckHasBit(cached_has_bits, 0x00000002U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this_._internal_positional(), target);
  }

  // optional bool push_to_talk = 3;
  if (CheckHasBit(cached_has_bits, 0x00000004U)) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this_._internal_push_to_talk(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MumbleProto.SuggestConfig)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SuggestConfig::ByteSizeLong(const MessageLite& base) {
  const SuggestConfig& this_ = static_cast<const SuggestConfig&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SuggestConfig::ByteSizeLong() const {
  const SuggestConfig& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:MumbleProto.SuggestConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000006U & cached_has_bits) * 2;
   {
    // optional uint32 version = 1;
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_version());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SuggestConfig::MergeImpl(::google::protobuf::MessageLite& to_msg,
                            const ::google::protobuf::MessageLite& from_msg) {
   auto* const _this =
      static_cast<SuggestConfig*>(&to_msg);
  auto& from = static_cast<const SuggestConfig&>(from_msg);
  if constexpr (::_pbi::DebugHardenCheckHasBitConsistency()) {
    from.CheckHasBitConsistency();
  }
  // @@protoc_insertion_point(class_specific_merge_from_start:MumbleProto.SuggestConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (BatchCheckHasBit(cached_has_bits, 0x00000007U)) {
    if (CheckHasBit(cached_has_bits, 0x00000001U)) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000002U)) {
      _this->_impl_.positional_ = from._impl_.positional_;
    }
    if (CheckHasBit(cached_has_bits, 0x00000004U)) {
      _this->_impl_.push_to_talk_ = from._impl_.push_to_talk_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}

void SuggestConfig::CopyFrom(const SuggestConfig& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:MumbleProto.SuggestConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SuggestConfig::InternalSwap(SuggestConfig* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.push_to_talk_)
      + sizeof(SuggestConfig::_impl_.push_to_talk_)
      - PROTOBUF_FIELD_OFFSET(SuggestConfig, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::google::protobuf::Metadata SuggestConfig::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace MumbleProto
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_Mumble_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
